<?xml version="1.0"?>
<doc>
    <assembly>
        <name>AngouriMath</name>
    </assembly>
    <members>
        <member name="T:AngouriMath.Extensions.AngouriMathExtensions">
            <summary>
            Class for some convenient extensions
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String},System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 2 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String},System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 3 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 4 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 5 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 6 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 7 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.ValueTuple{System.String}},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 8 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.ValueTuple{System.String,System.String}},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>Solves a given set of arbitrary equations</summary>
            <returns>A tensor whose width is 9 columns long or null if no solutions were found</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Int32,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Double})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Double,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Single})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Single,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.String})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.String,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Int32"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Int32})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Int32,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Double})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Double,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Single})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Single,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.String})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Double,System.Boolean,System.String,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Double"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Int32})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Int32,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Double})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Double,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Single})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Single,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.String})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.Single,System.Boolean,System.String,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.Single"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Int32})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Boolean,System.Int32,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.Int32"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Double})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Boolean,System.Double,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.Double"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Single})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Boolean,System.Single,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.Single"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.String})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToInterval(System.ValueTuple{System.String,System.Boolean,System.String,System.Boolean})">
            <summary>
            Takes a <see cref="T:System.String"/> and <see cref="T:System.String"/> and returns
            a closed interval (so that left and right ends are included)
            </summary>
            <returns>Interval</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToVector(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Converts a given sequence of elements into a vector,
            which is a one-column matrix
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SumAll(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Sums all the given terms and returns the resulting expression
            new Entity[]{ 1, 2, 3 }.SumAll() -> "1 + 2 + 3"
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.MultiplyAll(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Multiplies all the given terms and returns the resulting expression
            new Entity[]{ 1, 2, 3 }.MultiplyAll() -> "1 * 2 * 3"
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToPiecewise(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf})">
            <summary>
            Converts an <see cref="T:System.Collections.IEnumerable"/> into a piecewise function
            </summary>
            <returns>A Piecewise node</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToProvided(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Converts a tuple of an expression and its predicate to a 
            Provided node
            </summary>
            <returns>Providedf node</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToSet(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Converts your <see cref="T:System.Collections.IEnumerable"/> into a set of unique values.
            </summary>
            <returns>A Set</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Unite(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Set})">
            <summary>
            Unites your <see cref="T:System.Collections.IEnumerable"/> into one <see cref="T:AngouriMath.Entity.Set"/>.
            Applies the "or" operator on those nodes
            </summary>
            <returns>A set of unique elements</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Intersect(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Set})">
            <summary>
            Computes the intersection of your <see cref="T:System.Collections.IEnumerable"/>'s and makes it one <see cref="T:AngouriMath.Entity.Set"/>.
            Applies the "and" operator on those nodes
            </summary>
            <returns>A set of unique elements</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToEntity(System.String)">
            <summary>
            Parses the expression into <see cref="T:AngouriMath.Entity"/>.
            Synonymical to <see cref="M:AngouriMath.MathS.FromString(System.String)"/>
            </summary>
            <returns>Expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToEntity(System.ValueTuple{AngouriMath.Entity,System.Boolean,AngouriMath.Entity,System.Boolean})">
            <summary>
            Takes a tuple of four and builds an interval
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Simplify(System.String)">
            <summary>
            Parses this and simplifies by running <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/>
            </summary>
            <returns>Simplified expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Simplify(System.String,System.Int32)">
            <summary>
            Parses this and simplifies by running <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/>
            </summary>
            <returns>Simplified expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.EvalNumerical(System.String)">
            <summary>
            Parses this and evals into a number by running <see cref="M:AngouriMath.Entity.EvalNumerical"/>
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.CannotEvalException">
            This thrown when the given expression is boolean, tensoric, or contains variables.
            First, check whether it can be evaled: <see cref="P:AngouriMath.Entity.EvaluableNumerical"/>
            </exception>
            <returns>Collapses into one expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.EvalBoolean(System.String)">
            <summary>
            Parses this and evals into a boolean by running <see cref="M:AngouriMath.Entity.EvalBoolean"/>
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.CannotEvalException">
            This thrown when the given expression is numerical, tensoric, or contains variables.
            First, check whether it can be evaled: <see cref="P:AngouriMath.Entity.EvaluableBoolean"/>
            </exception>
            <returns>Collapses into one expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Expand(System.String)">
            <summary>
            Parses and expands the given expression so that as many parentheses as possible
            get expanded into a linear expression.
            </summary>
            <returns>An expanded expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Factorize(System.String)">
            <summary>
            Parses and factorizes the given expression so that as few powers as possible remain,
            and the expression is represented as a product of multipliers
            </summary>
            <returns>A factorized expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Substitute(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity)">
            <summary>
            Subsitutes a variable by replacing all its occurances with the given value
            </summary>
            <param name="expr">The expression where to substitute the variables</param>
            <param name="var">A variable to substitute</param>
            <param name="value">A value to substitute <paramref name="var"/></param>
            <returns>Expression with substituted the variable</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Substitute(System.String,System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity},System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Replaces x.x1 with value.v1 and
            x.x2 with value.v2
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Substitute(System.String,System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity},System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Replaces x.x1 with value.v1 and
            x.x2 with value.v2 and
            x.x3 with value.v3
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Substitute(System.String,System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity},System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Replaces x.x1 with value.v1 and
            x.x2 with value.v2 and
            x.x3 with value.v3 and
            x.x4 with value.v4
            </summary>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.SolveEquation(System.String,AngouriMath.Entity.Variable)">
            <summary>
            Solves the given equation
            </summary>
            <param name="expr">The function of <paramref name="x"/> that is assumed to be 0</param>
            <param name="x">The variable to solve over</param>
            <returns>A <see cref="T:AngouriMath.Entity.Set"/> of roots</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Solve(System.String,AngouriMath.Entity.Variable)">
            <summary>
            Solves the statement. The given expression must be boolean type,
            for example, equality, or boolean operators.
            </summary>
            <param name="expr">The statement of <paramref name="var"/> that is assumed to be true</param>
            <param name="var">The variables over which to solve</param>
            <returns>A <see cref="T:AngouriMath.Entity.Set"/> of roots</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(System.Int32)">
            <summary>
            Converts an <see cref="T:System.Int32"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Integer"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Integer"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(System.Int64)">
            <summary>
            Converts an <see cref="T:System.Int64"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Integer"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Integer"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(PeterO.Numbers.EInteger)">
            <summary>
            Converts PeterO's <see cref="T:PeterO.Numbers.EInteger"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Integer"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Integer"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(System.Single)">
            <summary>
            Converts an <see cref="T:System.Single"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Real"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(System.Double)">
            <summary>
            Converts an <see cref="T:System.Double"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Real"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(System.Decimal)">
            <summary>
            Converts an <see cref="T:System.Decimal"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Real"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(PeterO.Numbers.EDecimal)">
            <summary>
            Converts PeterO's <see cref="T:PeterO.Numbers.EDecimal"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Real"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToNumber(System.Numerics.Complex)">
            <summary>
            Converts Numerics's <see cref="T:System.Numerics.Complex"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Complex"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Number.Complex"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.ToBoolean(System.Boolean)">
            <summary>
            Converts an <see cref="T:System.Boolean"/> into an AM's understandable <see cref="T:AngouriMath.Entity.Boolean"/>
            which can be hung with others
            </summary>
            <returns>AM's <see cref="T:AngouriMath.Entity.Boolean"/></returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Latexise(System.String)">
            <summary>
            Builds a LaTeX code from an expression
            </summary>
            <returns>A <see cref="T:System.String"/> which can be rendered into pretty output</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile(System.String,AngouriMath.Entity.Variable[])">
            <summary>
            Compiles an expression into a special compiled code that runs via
            AM's virtual machine. Soon will be deprecated and replaced with compilation to
            delegate
            </summary>
            <param name="str">From which function to compile</param>
            <param name="variables">The array of variables should cover all variables from the expression</param>
            <returns>A compiled expression</returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Derive(System.String,AngouriMath.Entity.Variable)">
            <summary>
            Finds the symbolical derivative of the given expression
            </summary>
            <param name="str">
            The expresion to be parsed and differentiated
            </param>
            <param name="x">
            Over which variable to find the derivative
            </param>
            <returns>
            The derived expression which might contain <see cref="T:AngouriMath.Entity.Derivativef"/> nodes,
            or the initial one
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Differentiate(System.String,AngouriMath.Entity.Variable)">
            <summary>
            Finds the symbolical derivative of the given expression
            </summary>
            <param name="str">
            The expresion to be parsed and differentiated
            </param>
            <param name="x">
            Over which variable to find the derivative
            </param>
            <returns>
            The derived expression which might contain <see cref="T:AngouriMath.Entity.Derivativef"/> nodes,
            or the initial one
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Integrate(System.String,AngouriMath.Entity.Variable)">
            <summary>
            Integrates the given expression over the `x` variable, if can.
            May return an unresolved <see cref="T:AngouriMath.Entity.Integralf"/> node.
            </summary>
            <param name="str">
            The expression to be parsed and integrated over <paramref name="x"/>
            </param>
            <param name="x">Over which to integrate</param>
            <returns>
            An integrated expression. It might remain the same,
            it might have no integrals, and it might be transformed so that
            only a few nodes have unresolved integrals.
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Limit(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>
            Finds the limit of the given expression over the given variable
            </summary>
            <param name="str">
            The expression to be parsed and whose limit to be computed
            </param>
            <param name="x">
            The variable to be approaching
            </param>
            <param name="destination">
            A value where the variable approaches. It might be a symbolic
            expression, a finite number, or an infinite number, for example,
            "sqrt(x2 + x) / (3x + 3)".Limit("x", "+oo", ApproachFrom.BothSides)
            </param>
            <param name="side">
            From where to approach it: from the left, from the right,
            or BothSides, implying that if limits from either are not
            equal, there is no limit
            </param>
            <returns>
            A result or the <see cref="T:AngouriMath.Entity.Limitf"/> node if the limit
            cannot be determined
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Limit(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity)">
            <summary>
            Finds the limit of the given expression over the given variable
            </summary>
            <param name="str">The expression to be parsed and whose limit to be found</param>
            <param name="x">
            The variable to be approaching
            </param>
            <param name="destination">
            A value where the variable approaches. It might be a symbolic
            expression, a finite number, or an infinite number, for example,
            "sqrt(x2 + x) / (3x + 3)".Limit("x", "+oo")
            </param>
            <returns>
            A result or the <see cref="T:AngouriMath.Entity.Limitf"/> node if the limit
            cannot be determined
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``1(System.String,AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol,System.Type,System.Collections.Generic.IEnumerable{System.ValueTuple{System.Type,AngouriMath.Entity.Variable}})">
            <summary>
            Compiles a given expression into a native lambda
            </summary>
            <typeparam name="TDelegate">
            The type of your delegate to convert to
            </typeparam>
            <param name="this">
            The object of which the method is called
            </param>
            <param name="protocol">
            This is a protocol, according to which all nodes get compiled. Use this
            if you want to use the compilation for types different from those standard
            </param>
            <param name="returnType">
            The type to which the resulting type will be casted
            </param>
            <param name="typesAndNames">
            An <see cref="T:System.Collections.IEnumerable"/> of pairs, where the first element is the type of your argument,
            and the second one is the corresponding variable from the expression
            </param>
            <returns>
            Returnes a natively compiled expression of type <typeparamref name="TDelegate"/>
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``2(System.String,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``3(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``4(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``5(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``6(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``7(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <param name="var6">
            The variable corresponding to the function's argument number 6
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``8(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam>
            <typeparam name="TIn7">
            The type of the passed argument number 7
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <param name="var6">
            The variable corresponding to the function's argument number 6
            </param>
            <param name="var7">
            The variable corresponding to the function's argument number 7
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Extensions.AngouriMathExtensions.Compile``9(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary>
            <param name="this">
            The object of which the method is called
            </param>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam>
            <typeparam name="TIn7">
            The type of the passed argument number 7
            </typeparam>
            <typeparam name="TIn8">
            The type of the passed argument number 8
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <param name="var6">
            The variable corresponding to the function's argument number 6
            </param>
            <param name="var7">
            The variable corresponding to the function's argument number 7
            </param>
            <param name="var8">
            The variable corresponding to the function's argument number 8
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="T:AngouriMath.MathS">
            <summary>Use functions from this class</summary>
        </member>
        <member name="T:AngouriMath.MathS.Diagnostic">
            <summary>
            This class is used for diagnostic and debug of the library itself.
            Usually, you do not want to use it in production code.
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Diagnostic.OutputExplicit">
            <summary>
            Explicit output for ToString, that is, no signs or parentheses will be omitted. Useful
            for debugging and diagnostic.
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Diagnostic.CatchOnSimplify">
            <summary>
            Set a predicate on the state of <see cref="T:AngouriMath.Entity"/> so that once
            the predicate turns true in method <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/>,
            an exception <see cref="T:AngouriMath.MathS.Diagnostic.DiagnosticCatchException"/> is thrown.
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.Diagnostic.DiagnosticCatchException">
            <summary>
            Will only occur in debug mode,
            is used if a case defined by Diagnostic settings turns true
            (e. g. if you got unexpected result in simplify, change catchOnSimplify to this result
            and see, at which point it becomes such)
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.ExperimentalFeatures">
            <summary>
            Features that might become stable
            in the future, but are not guaranteed
            to do anything useful or correctly
            at the current moment.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.SolveDiophantineEquation(AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer)">
            <summary>
            Solves an equation
            a x + b y = c
            </summary>
            <returns>
            x and y if found, null otherwise
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.DecomposeRational(AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer)">
            <summary>
            Decomposes an arbitrary rational
            number into sum of rationals a_i / p_i^k,
            where p_i is a prime number. Evaluates
            lazily.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.DecomposeRational(AngouriMath.Entity.Number.Rational)">
            <summary>
            Decomposes an arbitrary rational
            number into sum of rationals a_i / p_i^k,
            where p_i is a prime number. Evaluates
            lazily.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.GetSineOfHalvedAngle(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            We are given angle theta and sin(theta)
            This function returns sin(theta / 2).
            </summary>
            <param name="theta">
            An angle, sine of half of which
            will be computed (that is, if
            you have sin(2x), then pass 2x here).
            </param>
            <param name="sin2x">
            The value of the sine of
            doubled angle.
            </param>
            <returns>
            The value of sine of half of the
            given angle if can (null otherwise)
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.GetCosineOfHalvedAngle(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            We are given angle theta and cos(theta)
            This function returns cos(theta / 2).
            </summary>
            <param name="theta">
            An angle, cosine of half of which
            will be computed (that is, if
            you have cos(2x), then pass 2x here).
            </param>
            <param name="cos2x">
            The value of the cosine of
            doubled angle.
            </param>
            <returns>
            The value of cosine of half of the
            given angle if can (null otherwise)
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.ExpandSineArgumentMultiplied(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            Assume you have sin(n x), where
            n is an integer number. Then
            sin(n x) can be easily represented
            as a combination of arithmetic operations
            of sin(x) and cos(x), which is exactly what
            this function does.
            </summary>
            <param name="sinx">
            The value of sin(x)
            </param>
            <param name="cosx">
            The value of cos(x)
            </param>
            <param name="n">
            The integer multiplier of the
            angle in the original sin(n x)
            </param>
            <returns>
            Expanded sine.
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.ExpandCosineArgumentMultiplied(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            Assume you have cos(n x), where
            n is an integer number. Then
            cos(n x) can be easily represented
            as a combination of arithmetic operations
            of sin(x) and cos(x), which is exactly what
            this function does.
            </summary>
            <param name="sinx">
            The value of sin(x)
            </param>
            <param name="cosx">
            The value of cos(x)
            </param>
            <param name="n">
            The integer multiplier of the
            angle in the original cos(n x)
            </param>
            <returns>
            Expanded cosine.
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.ExpandSineOfSum(System.Collections.Generic.IReadOnlyList{System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity}})">
            <summary>
            Expands a sine over terms
            via binary expansion.
            TODO: more docs
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.ExpandCosineOfSum(System.Collections.Generic.IReadOnlyList{System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity}})">
            <summary>
            Expands a cosine over terms
            via binary expansion.
            TODO: more docs
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.SymbolicFormOfSine(AngouriMath.Entity)">
            <summary>
            Finds the symbolic form of sine, if can
            For example, sin(9/14) is sin(1/2 + 1/7) which
            can be expanded as a sine of sum and hence
            an analytical (symbolic) form.
            </summary>
            <param name="angle">
            The angle in radians
            </param>
            <returns>
            The sine's symbolic form
            or null if cannot find it
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ExperimentalFeatures.SymbolicFormOfCosine(AngouriMath.Entity)">
            <summary>
            Finds the symbolic form of cosine, if can
            For example, cos(9/14) is cos(1/2 + 1/7) which
            can be expanded as a cosine of sum and hence
            an analytical (symbolic) form.
            </summary>
            <param name="angle">
            The angle in radians
            </param>
            <returns>
            The cosine's symbolic form
            or null if cannot find it
            </returns>
        </member>
        <member name="T:AngouriMath.MathS.NumberTheory">
            <summary>Use it in order to explore further number theory</summary>
        </member>
        <member name="M:AngouriMath.MathS.NumberTheory.Phi(AngouriMath.Entity)">
            <summary>
            Returns entity standing for Euler phi function
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function"/>
            </summary>
            If integer x is non-positive, the result will be 0
        </member>
        <member name="M:AngouriMath.MathS.NumberTheory.CountDivisors(AngouriMath.Entity.Number.Integer)">
            <summary>
            Count of all divisors of an integer
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.NumberTheory.Factorize(AngouriMath.Entity.Number.Integer)">
            <summary>
            Factorization of integer
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.NumberTheory.GreatestCommonDivisor(AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer)">
            <summary>
            Finds the greatest common divisor
            of two integers
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Equations(AngouriMath.Entity[])">
            <summary>Use it to solve equations</summary>
            <param name="equations">
            An array of <see cref="T:AngouriMath.Entity"/> (or <see cref="T:System.String"/>s)
            the system consists of
            </param>
            <returns>An <see cref="T:AngouriMath.Core.EquationSystem"/> which can then be solved</returns>
        </member>
        <member name="M:AngouriMath.MathS.Equations(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>Use it to solve equations</summary>
            <param name="equations">
            An array of <see cref="T:AngouriMath.Entity"/> (or <see cref="T:System.String"/>s)
            the system consists of
            </param>
            <returns>An <see cref="T:AngouriMath.Core.EquationSystem"/> which can then be solved</returns>
        </member>
        <member name="M:AngouriMath.MathS.SolveEquation(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>Solves one equation over one variable</summary>
            <param name="equation">An equation that is assumed to equal 0</param>
            <param name="var">Variable whose values we are looking for</param>
            <returns>A <see cref="T:AngouriMath.Entity.Set"/> of possible values or intervals of values</returns>
        </member>
        <member name="M:AngouriMath.MathS.SolveBooleanTable(AngouriMath.Entity,AngouriMath.Entity.Variable[])">
            <summary>
            Solves a boolean expression. That is, finds all values for
            <paramref name="variables"/> such that the expression turns into True when evaluated
            Uses a simple table of truth
            Use <see cref="M:AngouriMath.Entity.SolveBoolean(AngouriMath.Entity.Variable)"/> for smart solving
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Sin(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions"/></summary>
            <param name="a">Argument node of sine</param>
            <returns>Sine node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Cos(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions"/></summary>
            <param name="a">Argument node of cosine</param>
            <returns>Cosine node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Sec(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions"/></summary>
            <param name="a">Argument node of secant</param>
            <returns>Cosine node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Cosec(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions"/></summary>
            <param name="a">Argument node of cosecant</param>
            <returns>Cosine node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Log(AngouriMath.Entity,AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Logarithm"/></summary>
            <param name="base">Base node of logarithm</param>
            <param name="x">Argument node of logarithm</param>
            <returns>Logarithm node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Log(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Logarithm"/></summary>
            <param name="x">Argument node of logarithm</param>
            <returns>Logarithm node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Pow(AngouriMath.Entity,AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Power_function"/></summary>
            <param name="base">Base node of power</param>
            <param name="power">Argument node of power</param>
            <returns>Power node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Sqrt(AngouriMath.Entity)">
            <summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function"/></summary>
            <param name="a">The argument of which square root will be taken</param>
            <returns>Power node with (1/2) as the power</returns>
        </member>
        <member name="M:AngouriMath.MathS.Cbrt(AngouriMath.Entity)">
            <summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function"/></summary>
            <param name="a">The argument of which cube root will be taken</param>
            <returns>Power node with (1/3) as the power</returns>
        </member>
        <member name="M:AngouriMath.MathS.Sqr(AngouriMath.Entity)">
            <summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function"/></summary>
            <param name="a">Argument to be squared</param>
            <returns>Power node with 2 as the power</returns>
        </member>
        <member name="M:AngouriMath.MathS.Tan(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions"/></summary>
            <param name="a">Argument node of which tangent will be taken</param>
            <returns>Tangent node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Cotan(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions"/></summary>
            <param name="a">Argument node of which cotangent will be taken</param>
            <returns>Cotangent node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Arcsin(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"/></summary>
            <param name="a">Argument node of which arcsine will be taken</param>
            <returns>Arcsine node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Arccos(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"/></summary>
            <param name="a">Argument node of which arccosine will be taken</param>
            <returns>Arccosine node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Arctan(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"/></summary>
            <param name="a">Argument node of which arctangent will be taken</param>
            <returns>Arctangent node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Arccotan(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"/></summary>
            <param name="a">Argument node of which arccotangent will be taken</param>
            <returns>Arccotangent node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Arcsec(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"/></summary>
            <param name="a">Argument node of which arcsecant will be taken</param>
            <returns>Arccosine node with the reciprocal of the argument</returns>
        </member>
        <member name="M:AngouriMath.MathS.Arccosec(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions"/></summary>
            <param name="a">Argument node of which arccosecant will be taken</param>
            <returns>Arcsine node with the reciprocal of the argument</returns>
        </member>
        <member name="M:AngouriMath.MathS.Ln(AngouriMath.Entity)">
            <summary>
            Is a special case of logarithm where the base equals
            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">e</a>:
            <a href="https://en.wikipedia.org/wiki/Natural_logarithm"/>
            </summary>
            <param name="a">Argument node of which natural logarithm will be taken</param>
            <returns>Logarithm node with base equal to e</returns>
        </member>
        <member name="M:AngouriMath.MathS.Factorial(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Factorial"/></summary>
            <param name="a">Argument node of which factorial will be taken</param>
            <returns>Factorial node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Gamma(AngouriMath.Entity)">
            <summary><a href="https://en.wikipedia.org/wiki/Gamma_function"/></summary>
            <param name="a">Argument node of which gamma function will be taken</param>
            <returns>Factorial node with one added to the argument</returns>
        </member>
        <member name="M:AngouriMath.MathS.Signum(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Sign_function</summary>
            <param name="a">Argument node of which Signum function will be taken</param>
            <returns>Signum node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Abs(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Absolute_value</summary>
            <param name="a">Argument node of which Abs function will be taken</param>
            <returns>Abs node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Negation(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Negation</summary>
            <param name="a">Argument node of which Negation function will be taken</param>
            <returns>The Not node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Provided(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            This will be turned into <paramref name="expression"/> if the <paramref name="condition"/> is true,
            into NaN if <paramref name="condition"/> is false, and remain the same otherwise
            </summary>
            <param name="expression">The expression is extracted if the predicate is true</param>
            <param name="condition">Condition when the expression is defined</param>
            <returns>The Provided node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Piecewise(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf},AngouriMath.Entity)">
            <summary>
            This is a piecewisely defined function, which turns into a particular definition
            once there exists a case number N such that case[N].Predicate is turned into true and
            for all i less than N : case[i].Predicate is turned into false.
            
            For example, Piecewise(new Providedf(a, b), new Providedf(d, false), new Providedf(f, true))
            will remain unchanged, because the first case is uncertain.
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, true))
            will turn into f
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, false))
            will turn into NaN
            </summary>
            <param name="cases">
            Cases, each of type Provided.
            </param>
            <param name="otherwise">
            An otherwise case. Will be intepreted as otherwise.Provided(true). Optional.
            </param>
        </member>
        <member name="M:AngouriMath.MathS.Piecewise(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity}[])">
            <summary>
            This is a piecewisely defined function, which turns into a particular definition
            once there exists a case number N such that case[N].Predicate is turned into true and
            for all i less than N : case[i].Predicate is turned into false.
            
            For example, Piecewise((a, b), (d, false), (f, true))
            will remain unchanged, because the first case is uncertain.
            
            Piecewise((a, false), (d, false), (f, true))
            will turn into f
            
            Piecewise((a, false), (d, false), (f, false))
            will turn into NaN
            </summary>
            <param name="cases">
            Tuples of two expressions: an expression and a predicate
            </param>
        </member>
        <member name="T:AngouriMath.MathS.Hyperbolic">
            <summary>
            Represents a few hyperbolic functions
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Sinh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Cosh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Tanh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Cotanh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Sech(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Cosech(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Arsinh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Arcosh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Artanh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Arcotanh(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Arsech(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions</summary>
        </member>
        <member name="M:AngouriMath.MathS.Hyperbolic.Arcosech(AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Inverse_hyperbolic_functions</summary>
        </member>
        <member name="T:AngouriMath.MathS.Series">
            <summary>
            That is a collection of some series, expressed in a symbolic form
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Series.Maclaurin(AngouriMath.Entity,System.Int32,AngouriMath.Entity.Variable[])">
            <summary>
            Finds the symbolic expression of terms of the Maclaurin expansion of the given function,
            https://en.wikipedia.org/wiki/Taylor_series
            </summary>
            <param name="expr">
            The function to find the Taylor expansion of
            </param>
            <param name="degree">
            The degree of the resulting taylor polynomial (and the variable in the resulting series)
            </param>
            <param name="exprVariables">
            The variable/s to take the series over (and the variable the series will be over)
            (e. g. if you have expr = Sin("t"), then you may want to use "t" for this argument)
            </param>
            <returns>
            An expression in the polynomial form over the expression variables given in <paramref name="exprVariables"/>
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Series.Taylor(AngouriMath.Entity,System.Int32,System.ValueTuple{AngouriMath.Entity.Variable,AngouriMath.Entity}[])">
            <summary>
            Finds the symbolic expression of terms of the Taylor expansion of the given function,
            https://en.wikipedia.org/wiki/Taylor_series
            </summary>
            <param name="expr">
            The function to find the Taylor expansion of
            </param>
            <param name="degree">
            The degree of the resulting taylor polynomial
            </param>
            <param name="exprVariables">
            The variable/s to take the series over (and the variable in the resulting series),
            plus the variable values at which the Taylor polynomial will be found
            (e. g. if you want to find the taylor polynomial of Sin("t") around t=1, then you may want to use ("t","1") for this argument)
            </param>
            <returns>
            An expression in the polynomial form over the expression variable/s given in <paramref name="exprVariables"/>
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Series.Taylor(AngouriMath.Entity,System.Int32,System.ValueTuple{AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity}[])">
            <summary>
            Finds the symbolic expression of terms of the Taylor expansion of the given function,
            https://en.wikipedia.org/wiki/Taylor_series
            </summary>
            <param name="expr">
            The function to find the Taylor expansion of
            </param>
            <param name="degree">
            The degree of the resulting taylor polynomial
            </param>
            <param name="exprToPolyVars">
            The variable/s to take the series over, the variable the series will be over,
            and the variable values at which the Taylor polynomial will be found
            (e. g. if you want to find the taylor polynomial of Sin("t") around t=1, and want
             n to take that place in the series, then you may want to use ("t","n","1") for this argument)
            </param>
            <returns>
            An expression in the polynomial form over the poly variable/s given in <paramref name="exprToPolyVars"/>
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Series.TaylorTerms(AngouriMath.Entity,System.ValueTuple{AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity}[])">
            <summary>
            Finds the symbolic expression of terms of the Taylor expansion of the given function,
            https://en.wikipedia.org/wiki/Taylor_series
            
            Do NOT call ToArray() or anything like this on the result of this method. It is 
            infinite iterator. To get a finite result as in a sum of finite number of terms,
            call TaylorExpansion
            </summary>
            <param name="expr">
            The function to find the Taylor expansion of
            </param>
            <param name="exprToPolyVars">
            The variable/s to take the series over, the variable the series will be over,
            and the variable values at which the Taylor polynomial will be found
            (e. g. if you want to find the taylor polynomial of Sin("t") around t=1, and want
             n to take that place in the series, then you may want to use ("t","n","1") for this argument)
            </param>
            <returns>
            An infinite iterator over the terms of Taylor series of the given expression.
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Disjunction(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Logical_disjunction</summary>
            <param name="a">The left argument node of which Disjunction function will be taken</param>
            <param name="b">The right argument node of which Disjunction function will be taken</param>
            <returns>Or node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Conjunction(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Logical_conjunction</summary>
            <param name="a">Left argument node of which Conjunction function will be taken</param>
            <param name="b">Right argument node of which Conjunction disjunction function will be taken</param>
            <returns>And node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Implication(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)</summary>
            <param name="assumption">The assumption node</param>
            <param name="conclusion">The conclusion node</param>
            <returns>Implies node</returns>
        </member>
        <member name="M:AngouriMath.MathS.ExclusiveDisjunction(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>https://en.wikipedia.org/wiki/Exclusive_or</summary>
            <param name="a">Left argument node of which Exclusive disjunction function will be taken</param>
            <param name="b">Right argument node of which Exclusive disjunction function will be taken</param>
            <returns>Xor node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Equality(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Do NOT confuse it with Equation
            </summary>
            <param name="a">Left argument node of which Equality function will be taken</param>
            <param name="b">Right argument node of which Equality disjunction function will be taken</param>
            <returns>An Equals node</returns>
        </member>
        <member name="M:AngouriMath.MathS.GreaterThan(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">Left argument node of which the greater than node will be taken</param>
            <param name="b">Right argument node of which the greater than node function will be taken</param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.LessThan(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">Left argument node of which the less than node will be taken</param>
            <param name="b">Right argument node of which the less than node function will be taken</param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.GreaterOrEqualThan(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">Left argument node of which the greter than or equal node will be taken</param>
            <param name="b">Right argument node of which the greater than or equal node function will be taken</param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.LessOrEqualThan(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">Left argument node of which the less than or equal node will be taken</param>
            <param name="b">Right argument node of which the less than or equal node function will be taken</param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Union(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">Left argument node of which the union set node will be taken</param>
            <param name="b">Right argument node of which the union set node will be taken</param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Intersection(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">Left argument node of which the intersection set node will be taken</param>
            <param name="b">Right argument node of which the intersection set node will be taken</param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.SetSubtraction(AngouriMath.Entity,AngouriMath.Entity)">
            <param name="a">
            Left argument node of which the set subtraction node will be taken
            That is, the resulting set of set subtraction is necessarily superset of this set
            </param>
            <param name="b">
            Right argument node of which the set subtraction set node will be taken
            That is, there is no element in the resulting set that belong to this one
            </param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.MathS.Var(System.String)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Variable"/>.</summary>
            <param name="name">The name of the <see cref="T:AngouriMath.Entity.Variable"/> which equality is based on.</param>
            <returns>Variable node</returns>
        </member>
        <member name="F:AngouriMath.MathS.e">
            <summary>
            The e constant
            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)"/>
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.i">
            <summary>
            The imaginary one
            <a href="https://en.wikipedia.org/wiki/Imaginary_unit"/>
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.pi">
            <summary>
            The pi constant
            <a href="https://en.wikipedia.org/wiki/Pi"/>
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.NaN">
            <summary>
            That is both undefined and indeterminite
            Any operation on NaN returns NaN
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.I_1">
            <summary>
            The square identity matrix of size 1
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.I_2">
            <summary>
            The square identity matrix of size 2
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.I_3">
            <summary>
            The square identity matrix of size 3
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.I_4">
            <summary>
            The square identity matrix of size 4
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.O_1">
            <summary>
            The square zero matrix of size 1
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.O_2">
            <summary>
            The square zero matrix of size 2
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.O_3">
            <summary>
            The square zero matrix of size 3
            </summary>
        </member>
        <member name="F:AngouriMath.MathS.O_4">
            <summary>
            The square zero matrix of size 4
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.FromString(System.String,System.Boolean)">
            <summary>Converts a <see cref="T:System.String"/> to an expression</summary>
            <param name="expr"><see cref="T:System.String"/> expression, for example, <code>"2 * x + 3 + sqrt(x)"</code></param>
            <param name="useCache">By default is true, it boosts performance if you have multiple uses of the same string,
            for example, 
            Entity expr = (Entity)"+oo" + "x".Limit("x", "+oo") * "+oo";
            First occurance will be parsed, others will be replaced with the cached entity
            </param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:AngouriMath.MathS.FromString(System.String)">
            <summary>Converts a <see cref="T:System.String"/> to an expression</summary>
            <param name="expr"><see cref="T:System.String"/> expression, for example, <code>"2 * x + 3 + sqrt(x)"</code></param>
            <returns>The parsed expression</returns>
        </member>
        <member name="M:AngouriMath.MathS.Parse(System.String)">
            <summary>
            Parses an expression silently, that is,
            without throwing an exception. Instead,
            it returns a Failure in case of encountered
            errors during parsing.
            </summary>
            <returns>
            Returns a type union of the successful result and
            failure, which is a type union of multiple reasons
            it may have failed.
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ToBaseN(AngouriMath.Entity.Number.Real,System.Int32)">
            <summary>Translates a <see cref="T:AngouriMath.Entity.Number"/> in base 10 into base <paramref name="N"/></summary>
            <param name="num">A <see cref="T:AngouriMath.Entity.Number.Real"/> in base 10 to be translated into base <paramref name="N"/></param>
            <param name="N">The base to translate the number into</param>
            <returns>A <see cref="T:System.String"/> with the number in the required base</returns>
        </member>
        <member name="M:AngouriMath.MathS.FromBaseN(System.String,System.Int32)">
            <summary>Translates a number in base <paramref name="N"/> into base 10</summary>
            <param name="num">A <see cref="T:AngouriMath.Entity.Number.Real"/> in base <paramref name="N"/> to be translated into base 10</param>
            <param name="N">The base to translate the number from</param>
            <returns>The <see cref="T:AngouriMath.Entity.Number.Real"/> in base 10</returns>
        </member>
        <member name="M:AngouriMath.MathS.Latex(AngouriMath.Core.ILatexiseable)">
            <returns>
            The <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> representation of the argument
            </returns>
            <param name="latexiseable">
            Any element (<see cref="T:AngouriMath.Entity"/>, <see cref="T:AngouriMath.Entity.Set"/>, etc.) that can be represented in LaTeX
            </param>
        </member>
        <member name="T:AngouriMath.MathS.Numbers">
             <summary>
             <para>All operations for <see cref="T:AngouriMath.Entity.Number"/> and its derived classes are available from here.</para>
            
             These methods represent the only possible way to explicitly create numeric instances.
             It will automatically downcast the result for you,
             so <code>Number.Create(1.0);</code> is an <see cref="T:AngouriMath.Entity.Number.Integer"/>.
             To avoid it, you may temporarily disable it
             <code>
             using var _ = MathS.Settings.DowncastingEnabled.Set(false);
             var yourNum = Number.Create(1.0);
             </code>
             and the result will be a <see cref="T:AngouriMath.Entity.Number.Real"/>.
             </summary>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(System.Numerics.Complex)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Complex"/> from a <see cref="T:System.Numerics.Complex"/></summary>
            <param name="value">A value of type <see cref="T:System.Numerics.Complex"/></param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Complex"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(System.Int64)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Integer"/> from a <see cref="T:System.Int64"/></summary>
            <param name="value">A value of type <see cref="T:System.Int64"/> (signed 64-bit integer)</param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Integer"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(PeterO.Numbers.EInteger)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Integer"/> from an <see cref="T:PeterO.Numbers.EInteger"/></summary>
            <param name="value">A value of type <see cref="T:PeterO.Numbers.EInteger"/></param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Integer"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(System.Int32)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Integer"/> from an <see cref="T:System.Int32"/></summary>
            <param name="value">A value of type <see cref="T:System.Int32"/> (signed 32-bit integer)</param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Integer"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.CreateRational(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Rational"/> from two <see cref="T:PeterO.Numbers.EInteger"/>s</summary>
            <param name="numerator">Numerator of type <see cref="T:PeterO.Numbers.EInteger"/></param>
            <param name="denominator">Denominator of type <see cref="T:PeterO.Numbers.EInteger"/></param>
            <returns>
            The resulting <see cref="T:AngouriMath.Entity.Number.Rational"/>
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(PeterO.Numbers.ERational)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Rational"/> from an <see cref="T:PeterO.Numbers.ERational"/></summary>
            <param name="rational">A value of type <see cref="T:PeterO.Numbers.ERational"/></param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Rational"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(PeterO.Numbers.EDecimal)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Real"/> from an <see cref="T:PeterO.Numbers.EDecimal"/></summary>
            <param name="value">A value of type <see cref="T:PeterO.Numbers.EDecimal"/></param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Real"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(System.Double)">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Number.Real"/> from a <see cref="T:System.Double"/></summary>
            <param name="value">A value of type <see cref="T:System.Double"/> (64-bit floating-point number)</param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Real"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Numbers.Create(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>
            Creates an instance of <see cref="T:AngouriMath.Entity.Number.Complex"/> from two <see cref="T:PeterO.Numbers.EDecimal"/>s
            </summary>
            <param name="re">
            Real part of the desired <see cref="T:AngouriMath.Entity.Number.Complex"/> of type <see cref="T:PeterO.Numbers.EDecimal"/>
            </param>
            <param name="im">
            Imaginary part of the desired <see cref="T:AngouriMath.Entity.Number.Complex"/> of type <see cref="T:PeterO.Numbers.EDecimal"/>
            </param>
            <returns>The resulting <see cref="T:AngouriMath.Entity.Number.Complex"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Det(AngouriMath.Entity.Matrix)">
            <summary>
            Finds the determinant of the given matrix. If
            the matrix is non-square, returns null
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Matrix(AngouriMath.Entity[0:,0:])">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Matrix"/>.</summary>
            <param name="values">
            A two-dimensional array of values.
            The first dimension is the row count, the second one is for columns.
            </param>
            <returns>A two-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> which is a matrix</returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrix(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,AngouriMath.Entity})">
            <summary>
            Creates an instance of matrix, where each cell's
            index is mapped to a value with the help of the
            mapping function.
            </summary>
            <param name="rowCount">
            The number of rows (corresponds to the first index).
            </param>
            <param name="colCount">
            The number of columns (corresponds to the second index).
            </param>
            <param name="map">
            The first argument of the mapping function
            function is the index of row, the second one for the 
            column index.
            
            Indexing starts from 0.
            </param>
            <returns>
            A newly created matrix of the given size.
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Vector(AngouriMath.Entity[])">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Matrix"/> that has one column.</summary>
            <param name="values">The cells of the <see cref="T:AngouriMath.Entity.Matrix"/></param>
            <returns>A one-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> which is a vector</returns>
        </member>
        <member name="M:AngouriMath.MathS.ZeroMatrix(System.Int32)">
            <summary>
            Creates a zero square matrix
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ZeroMatrix(System.Int32,System.Int32)">
            <summary>
            Creates a zero square matrix
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.ZeroVector(System.Int32)">
            <summary>
            Creates a zero vector
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Scalar(AngouriMath.Entity)">
            <summary>
            Creates a 1x1 matrix of a given value. It will be simplified
            once InnerSimplified or Evaled are addressed
            </summary>
            <returns>
            A 1x1 matrix, which is also a 1-long vector, or just a scalar.
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.MatrixFromRows(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Matrix})">
            <summary>
            Creates a matrix from given rows
            </summary>
            <param name="vectors">
            There should be at least one row.
            All rows must have the same number
            of columns
            </param>
        </member>
        <member name="M:AngouriMath.MathS.MatrixFromIEnum2x2(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{AngouriMath.Entity}})">
            <summary>
            Creates a matrix from given elements
            </summary>
            <param name="elements">
            There should be at least one row.
            All rows must have the same number
            of columns
            </param>
        </member>
        <member name="M:AngouriMath.MathS.Interval(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Creates a closed interval (segment)
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Interval(AngouriMath.Entity,System.Boolean,AngouriMath.Entity,System.Boolean)">
            <summary>
            Creates an interval with custom endings
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.IdentityMatrix(System.Int32)">
            <summary>
            Creates a square identity matrix
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.IdentityMatrix(System.Int32,System.Int32)">
            <summary>
            Creates a rectangular identity matrix
            with the given size
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.Matrices">
            <summary>Classes and functions related to matrices are defined here</summary>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.PointwiseMultiplication(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>
            Performs a pointwise multiplication operation,
            or throws exception if shapes mismatch
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.Matrix(System.Int32,System.Int32,AngouriMath.Entity[])">
            <summary>
            Creates an instance of <see cref="T:AngouriMath.Entity.Matrix"/> that is a matrix.
            Usage example:
            <code>
            var t = MathS.Matrix(5, 3,<br/>
            <list type="bullet"><list type="bullet"><list type="bullet"><list type="bullet">
                10, 11, 12,<br/>
                20, 21, 22,<br/>
                30, 31, 32,<br/>
                40, 41, 42,<br/>
                50, 51, 52);
            </list></list></list></list>
            </code>
            creates 5×3 matrix with the appropriate elements
            </summary>
            <param name="rows">Number of rows (first axis)</param>
            <param name="columns">Number of columns (second axis)</param>
            <param name="values">
            Array of values of the matrix so that its length is equal to
            the product of <paramref name="rows"/> and <paramref name="columns"/>
            </param>
            <returns>A two-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> which is a matrix</returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.Matrix(AngouriMath.Entity[0:,0:])">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Matrix"/> that is a matrix.</summary>
            <param name="values">A two-dimensional array of values</param>
            <returns>A two-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> which is a matrix</returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.Vector(AngouriMath.Entity[])">
            <summary>Creates an instance of <see cref="T:AngouriMath.Entity.Matrix"/> that is a vector.</summary>
            <param name="values">The cells of the <see cref="T:AngouriMath.Entity.Matrix"/></param>
            <returns>A one-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> which is a vector</returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.DotProduct(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>Returns the dot product of two <see cref="T:AngouriMath.Entity.Matrix"/>s that are matrices.</summary>
            <param name="A">First matrix (its width is the result's width)</param>
            <param name="B">Second matrix (its height is the result's height)</param>
            <returns>A two-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> (matrix) as a result of symbolic multiplication</returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.MatrixMultiplication(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>Returns the dot product of two <see cref="T:AngouriMath.Entity.Matrix"/>s that are matrices.</summary>
            <param name="A">First matrix (its width is the result's width)</param>
            <param name="B">Second matrix (its height is the result's height)</param>
            <returns>A two-dimensional <see cref="T:AngouriMath.Entity.Matrix"/> (matrix) as a result of symbolic multiplication</returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.ScalarProduct(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>Returns the scalar product of two <see cref="T:AngouriMath.Entity.Matrix"/>s that are vectors with the same length.</summary>
            <param name="a">First vector (order does not matter)</param>
            <param name="b">Second vector</param>
            <returns>The resulting scalar which is an <see cref="T:AngouriMath.Entity"/> and not a <see cref="T:AngouriMath.Entity.Matrix"/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.Interval(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Creates a closed interval (segment)
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Matrices.Interval(AngouriMath.Entity,System.Boolean,AngouriMath.Entity,System.Boolean)">
            <summary>
            Creates an interval with custom endings
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.Settings">
            <summary>
            A couple of settings allowing you to set some preferences for AM's algorithms
            To use these settings the syntax is
            <code>
            using var _ = MathS.Settings.SomeSetting.Set(5 /* Here you set a value to the setting */);
            // here you write your code normally
            </code>
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.ExplicitParsingOnly">
            <summary>
            Determine if it should only parse if it is explicit
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.Settings.NewtonSetting">
            <summary>
            That is how we perform newton solving when no analytical solution was found
            in <see cref="M:AngouriMath.Entity.Solve(AngouriMath.Entity.Variable)"/> and <see cref="M:AngouriMath.Entity.SolveEquation(AngouriMath.Entity.Variable)"/>
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.NewtonSetting.From">
            <summary>
            The point where we start going from
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.NewtonSetting.To">
            <summary>
            The point after which we do not perform seach
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.NewtonSetting.StepCount">
            <summary>
            The number of steps to go through for real and for complex part
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.NewtonSetting.Precision">
            <summary>
            How precise the result is required to be. The higher, the longer 
            the algorithm takes to return the result
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.DowncastingEnabled">
            <summary>
            Enables downcasting. Not recommended to turn off, disabling might be only useful for some calculations
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.FloatToRationalIterCount">
            <summary>
            Amount of iterations allowed for attempting to cast to a rational
            The more iterations, the larger fraction could be calculated
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.MaxAbsNumeratorOrDenominatorValue">
            <summary>
            If a numerator or denominator is too large, it's suspended to better keep the real number instead of casting
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.PrecisionErrorCommon">
            <summary>
            Sets threshold for comparison
            For example, if you don't need precision higher than 6 digits after .,
            you can set it to 1.0e-6 so 1.0000000 == 0.9999999
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.PrecisionErrorZeroRange">
            <summary>
            Numbers whose absolute value is less than PrecisionErrorZeroRange are considered zeros
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.AllowNewton">
            <summary>
            If you only need analytical solutions and an empty set if no analytical solutions were found, disable Newton's method
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.ComplexityCriteria">
            <summary>
            Criteria for simplifier so you could control which expressions are considered easier by you
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.NewtonSolver">
            <summary>
            Settings for the Newton-Raphson's root-search method
            e.g.
            <code>
            using var _ = MathS.Settings.NewtonSolver.Set(new NewtonSetting {
                From = (-10, -10),
                To = (10, 10),
                StepCount = (10, 10),
                Precision = 30
            });
            ...
            </code>
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.MaxExpansionTermCount">
            <summary>
            The maximum number of linear children of an expression in polynomial solver
            considering that there's no more than 1 children with the required variable, for example:
            <list type="table">
                <listheader>
                    <term>Expression</term>
                    <description>Complexity</description>
                </listheader>
                <item>
                    <term>(x + 2) ^ 2</term>
                    <description>3 [x2, 4x, 4]</description>
                </item>
                <item>
                    <term>x + 3 + a</term>
                    <description>2 [x, 3 + a]</description>
                </item>
                <item>
                    <term>(x + a)(b + c)</term>
                    <description>2 [(b + c)x, a(b + c)]</description>
                </item>
                <item>
                    <term>(x + 3 + a) / (x + 3)</term>
                    <description>2 [x / (x + 3), (3 + a) / (x + 3)]</description>
                </item>
                <item>
                    <term>x2 + x + 1</term>
                    <description>3 [x2, x, 1]</description>
                </item>
            </list>
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Settings.DecimalPrecisionContext">
            <summary>
            Settings for <see cref="T:PeterO.Numbers.EDecimal"/> precisions of <a href="https://github.com/peteroupc/Numbers">PeterO.Numbers</a>
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.TryPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@)">
            <summary>Returns an <see cref="T:AngouriMath.Entity"/> in polynomial order if possible</summary>
            <param name="expr">The unordered <see cref="T:AngouriMath.Entity"/></param>
            <param name="variable">The variable of the polynomial</param>
            <param name="dst">The ordered result</param>
            <returns>
            <see langword="true"/> if success,
            <see langword="false"/> otherwise (<paramref name="dst"/> will be <see langword="null"/>)
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.ToSympyCode(AngouriMath.Entity)">
            <returns>sympy interpretable format</returns>
            <param name="expr">An <see cref="T:AngouriMath.Entity"/> representing an expression</param>
        </member>
        <member name="T:AngouriMath.MathS.Sets">
            <summary>
            Functions and classes related to sets defined here
            
            Class <see cref="T:AngouriMath.Entity.Set"/> defines true mathematical sets
            It supports intersection, union, subtraction
                        
            <see cref="T:AngouriMath.Entity.Set"/>
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.Sets.Empty">
            <summary>Creates an instance of an empty <see cref="T:AngouriMath.Entity.Set"/></summary>
            <returns>A <see cref="T:AngouriMath.Entity.Set"/> with no elements</returns>
        </member>
        <member name="P:AngouriMath.MathS.Sets.C">
            <returns>A set of all Complexes/>s</returns>
        </member>
        <member name="P:AngouriMath.MathS.Sets.R">
            <returns>A set of all Reals/>s</returns>
        </member>
        <member name="P:AngouriMath.MathS.Sets.Q">
            <returns>A set of all Rationals/>s</returns>
        </member>
        <member name="P:AngouriMath.MathS.Sets.Z">
            <returns>A set of all Integers/></returns>
        </member>
        <member name="M:AngouriMath.MathS.Sets.Finite(AngouriMath.Entity[])">
            <summary>
            Creates a <see cref="T:AngouriMath.Entity.Set.FiniteSet"/> with given elements
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Sets.Finite(System.Collections.Generic.List{AngouriMath.Entity})">
            <summary>
            Creates a <see cref="T:AngouriMath.Entity.Set.FiniteSet"/> with given elements
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Sets.Interval(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Creates a closed interval
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Sets.Interval(AngouriMath.Entity,System.Boolean,AngouriMath.Entity,System.Boolean)">
            <summary>
            Creates an interval where <paramref name="leftClosed"/> shows whether <paramref name="from"/> is included,
            <paramref name="rightClosed"/> shows whether <paramref name="to"/> included.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Sets.ElementInSet(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Creates a node of whether the given element belongs to the given set
            </summary>
            <returns>A node</returns>
        </member>
        <member name="T:AngouriMath.MathS.Compute">
            <summary>
            Implements necessary functions for symbolic computation of limits, derivatives and integrals
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Limit(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>
            If possible, analytically computes the limit of <paramref name="expr"/>
            if <paramref name="var"/> approaches to <paramref name="approachDestination"/>
            from one of two sides (left and right).
            Returns <see langword="null"/> otherwise.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Limit(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity)">
            <summary>
            If possible, analytically computes the limit of <paramref name="expr"/>
            if <paramref name="var"/> approaches to <paramref name="approachDestination"/>.
            Returns <see langword="null"/> otherwise or if limits from left and right sides differ.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable,PeterO.Numbers.EInteger)">
            <summary>Derives over <paramref name="x"/> <paramref name="power"/> times</summary>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>Derivation over a variable (without simplification)</summary>
            <param name="expr">The expression to find derivative over</param>
            <param name="x">The variable to derive over</param>
            <returns>The derived result</returns>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Integral(AngouriMath.Entity,AngouriMath.Entity.Variable,PeterO.Numbers.EInteger)">
            <summary>Integrates over <paramref name="x"/> <paramref name="power"/> times</summary>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>Integrates over a variable (without simplification)</summary>
            <param name="expr">The expression to be integrated over <paramref name="x"/></param>
            <param name="x">The variable to integrate over</param>
            <returns>The integrated result</returns>
        </member>
        <member name="M:AngouriMath.MathS.Compute.DefiniteIntegral(AngouriMath.Entity,AngouriMath.Entity.Variable,System.ValueTuple{PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal},System.ValueTuple{PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal})">
            <summary>
            Returns a value of a definite integral of a function. Only works for one-variable functions
            </summary>
            <param name="expr">The expression to be numerically integrated over <paramref name="x"/></param>
            <param name="x">Variable to integrate over</param>
            <param name="from">The complex lower bound for integrating</param>
            <param name="to">The complex upper bound for integrating</param>
        </member>
        <member name="M:AngouriMath.MathS.Compute.DefiniteIntegral(AngouriMath.Entity,AngouriMath.Entity.Variable,PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>
            Returns a value of a definite integral of a function. Only works for one-variable functions
            </summary>
            <param name="expr">The function to be numerically integrated</param>
            <param name="x">Variable to integrate over</param>
            <param name="from">The real lower bound for integrating</param>
            <param name="to">The real upper bound for integrating</param>
        </member>
        <member name="M:AngouriMath.MathS.Compute.DefiniteIntegral(AngouriMath.Entity,AngouriMath.Entity.Variable,System.ValueTuple{PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal},System.ValueTuple{PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal},System.Int32)">
            <summary>
            Returns a value of a definite integral of a function. Only works for one-variable functions
            </summary>
            <param name="expr">The function to be numerically integrated</param>
            <param name="x">Variable to integrate over</param>
            <param name="from">The complex lower bound for integrating</param>
            <param name="to">The complex upper bound for integrating</param>
            <param name="stepCount">Accuracy (initially, amount of iterations)</param>
        </member>
        <member name="M:AngouriMath.MathS.Compute.Phi(AngouriMath.Entity.Number.Integer)">
            <summary>
            Computes Euler phi function
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function"/>
            </summary>
            If integer x is non-positive, the result will be 0
        </member>
        <member name="M:AngouriMath.MathS.Compute.SymbolicFormOfSine(AngouriMath.Entity)">
            <summary>
            Finds the symbolic form of sine, if can
            For example, sin(9/14) is sin(1/2 + 1/7) which
            can be expanded as a sine of sum and hence
            an analytical (symbolic) form.
            </summary>
            <param name="angle">
            The angle in radians
            </param>
            <returns>
            The sine's symbolic form
            or null if cannot find it
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Compute.SymbolicFormOfCosine(AngouriMath.Entity)">
            <summary>
            Finds the symbolic form of cosine, if can
            For example, cos(9/14) is cos(1/2 + 1/7) which
            can be expanded as a cosine of sum and hence
            an analytical (symbolic) form.
            </summary>
            <param name="angle">
            The angle in radians
            </param>
            <returns>
            The cosine's symbolic form
            or null if cannot find it
            </returns>
        </member>
        <member name="M:AngouriMath.MathS.Derivative(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Hangs your <see cref="T:AngouriMath.Entity"/> to a derivative node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)"/>)
            </summary>
            <param name="expr">Expression to be hung</param>
            <param name="var">Variable over which derivative is taken</param>
        </member>
        <member name="M:AngouriMath.MathS.Derivative(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            Hangs your <see cref="T:AngouriMath.Entity"/> to a derivative node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)"/>)
            </summary>
            <param name="expr">Expression to be hung</param>
            <param name="var">Variable over which derivative is taken</param>
            <param name="power">Number of times derivative is taken. Only integers will be simplified or evaluated.</param>
        </member>
        <member name="M:AngouriMath.MathS.Integral(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Hangs your entity to an integral node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)"/>)
            </summary>
            <param name="expr">Expression to be hung</param>
            <param name="var">Variable over which integral is taken</param>
        </member>
        <member name="M:AngouriMath.MathS.Integral(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            Hangs your entity to an integral node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)"/>)
            </summary>
            <param name="expr">Expression to be hung</param>
            <param name="var">Variable over which integral is taken</param>
            <param name="power">Number of times integral is taken. Only integers will be simplified or evaluated.</param>
        </member>
        <member name="M:AngouriMath.MathS.Limit(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>
            Hangs your entity to a limit node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Limit(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity)"/>)
            </summary>
            <param name="expr">Expression to be hung</param>
            <param name="var">Variable over which limit is taken</param>
            <param name="dest">Where <paramref name="var"/> approaches (could be finite or infinite)</param>
            <param name="approach">From where it approaches</param>
        </member>
        <member name="T:AngouriMath.MathS.DecimalConst">
            <summary>Some non-symbolic constants</summary>
        </member>
        <member name="P:AngouriMath.MathS.DecimalConst.pi">
            <summary><a href="https://en.wikipedia.org/wiki/Pi"/></summary>
        </member>
        <member name="P:AngouriMath.MathS.DecimalConst.e">
            <summary><a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)"/></summary>
        </member>
        <member name="T:AngouriMath.MathS.Boolean">
            <summary>
            Some operations on booleans are stored here
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Boolean.BuildTruthTable(AngouriMath.Entity,AngouriMath.Entity.Variable[])">
            <summary>
            Combines all possible values of <paramref name="variables"/>
            and has the last column as the result of the function
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Boolean.Create(System.Boolean)">
            <summary>
            Creates a boolean
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.Multithreading">
            <summary>
            A few functions convenient to use in industrial projects
            to keep the system more reliable and distribute computations
            to other threads
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Multithreading.SetLocalCancellationToken(System.Threading.CancellationToken)">
            <summary>
            Sets the thread-local cancellation token
            </summary>
            <param name="token"></param>
        </member>
        <member name="T:AngouriMath.MathS.Utils">
            <summary>
            Some additional functions that would be barely
            ever used by the user, but kept for "just in case" as public
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Utils.SmartExpandOver(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>
            Performs the expansion operation over the given variable
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.Utils.TryGetPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable,System.Collections.Generic.Dictionary{PeterO.Numbers.EInteger,AngouriMath.Entity}@)">
            <summary>
            Extracts a polynomial with integer powers
            </summary>
            <param name="expr">From which to extract the polynomial</param>
            <param name="variable">Over which variable to extract the polynomial</param>
            <param name="dst">
            Where to put the dictionary, whose keys
            are powers, and values - coefficients
            </param>
            <returns>Whether the input expression is a valid polynomial</returns>
        </member>
        <member name="M:AngouriMath.MathS.Utils.TryGetPolyLinear(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@,AngouriMath.Entity@)">
            <summary>
            Extracts the linear coefficient and the bias over a variable
            a x + b
            </summary>
            <param name="expr">From which to extract the linear function</param>
            <param name="variable">Over which to extract</param>
            <param name="a">The linear coefficient</param>
            <param name="b">The bias</param>
            <returns>Whether the extract was successful</returns>
        </member>
        <member name="M:AngouriMath.MathS.Utils.TryGetPolyQuadratic(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@,AngouriMath.Entity@,AngouriMath.Entity@)">
            <summary>
            Extracts the quadratic coefficient, linear coefficient and the bias over a variable
            a x ^ 2 + b x + c
            </summary>
            <param name="expr">From which to extract the quadratic function</param>
            <param name="variable">Over which to extract</param>
            <param name="a">The quadratic coefficient</param>
            <param name="b">The linear coefficient</param>
            <param name="c">The bias</param>
            <returns>Whether the extract was successful</returns>
        </member>
        <member name="T:AngouriMath.MathS.UnsafeAndInternal">
            <summary>
            You may need it to manually manage some issues.
            Although those functions might be used inside the library
            only, the user may want to use them for some reason
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.UnsafeAndInternal.ClearFromStringCache">
            <summary>
            When you implicitly convert string to an Entity,
            it caches the result by the string's reference.
            If very strict about RAM usage, you can manually
            clean it (or use <see cref="M:AngouriMath.MathS.FromString(System.String,System.Boolean)"/>
            instead and set the flag useCache to false)
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.UnsafeAndInternal.AreEqualNumerically(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity[])">
            <summary>
            Checks if two expressions are equivalent if 
            <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/> does not give the
            expected response
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.UnsafeAndInternal.AreEqualNumerically(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Checks if two expressions are equivalent if 
            <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/> does not give the
            expected response
            </summary>
        </member>
        <member name="P:AngouriMath.MathS.UnsafeAndInternal.CheckPoints">
            <summary>
            Checkpoints for numerical equality check
            </summary>
        </member>
        <member name="T:AngouriMath.MathS.UnsafeAndInternal.NativeExportAttribute">
            <summary>
            This attribute is applied to methods which are exported natively.
            </summary>
        </member>
        <member name="M:AngouriMath.MathS.UnsafeAndInternal.DivideByEntityStrict(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Divides the given expression by the divisor.
            Requires a given node to exactly match the divisor,
            so no "smart" division can be applied.
            (e. g. pi / 2 divide by pi would work, but
            (2 a) / 2 won't be divided by 4a)
            </summary>
            <returns>The result if valid, null otherwise</returns>
        </member>
        <member name="M:AngouriMath.MathS.UnsafeAndInternal.RepresentRational(AngouriMath.Entity.Number.Rational,System.Collections.Generic.IEnumerable{AngouriMath.Entity.Number.Rational})">
            <summary>
            If it can, it will find coefficients 
            [a_1, a_2, ..., a_n] such that for
            given rational forms [p_1, p_2, ..., p_n]
            it is true that 
            q = a_1 * p_1 + a_2 * p_2 + ... + a_n * p_n
            </summary>
            <returns>
            The sequence of pairs coef-form or
            null if it cannot find them
            </returns>
        </member>
        <member name="T:AngouriMath.Convenience.Setting`1">
            <summary>
            This class for configuring some internal mechanisms from outside
            </summary>
            <typeparam name="T">
            Those configurations can be of different types
            </typeparam>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.Global(`0)">
            <summary>
            Use it if you don't need to unset it
            Should be NOT used for industrial projects
            (only for some manual calculations)
            </summary>
            <param name="value">The new value of the setting</param>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.RollBackToDefault">
            <summary>
            Use it in case if you need to cancel any adjustments of the setting
            and rollback to the one predefined in <see cref="T:AngouriMath.MathS"/>.
            It does not roll back to the previous value. Instead, it sets the 
            value which is defined right after <see cref="T:AngouriMath.MathS"/> is
            initialized. If you need recoverable settings (aka local),
            use method <see cref="M:AngouriMath.Convenience.Setting`1.As(`0,System.Action)"/>.
            </summary>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.Set(`0)">
            <summary>
            Sets the new value for the setting
            </summary>
            <param name="value">
            New value of a setting
            </param>
            <returns>
            An <see cref="T:System.IDisposable"/> struct. Make sure to use operator `using` before, so that it auto-disposes
            once the method is over.
            Example:
            <code>
            using var _ = MathS.Settings.SomeSetting.Set(4);
            // do something, once the method is ended, the setting is automatically returned to the initial statement
            </code>
            </returns>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.As(`0,System.Action)">
            <summary>
            For example,
            <code>
            using var _ = MathS.Settings.Precision.Set(100);
            // your code here
            </code>
            </summary>
            <param name="value">New value that will be automatically reverted after action is done</param>
            <param name="action">What should be done under this setting</param>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.As``1(`0,System.Func{``0})">
            <summary>
            For example,
            <code>
            var res = MathS.Settings.Precision.As(100, () => { /* some code considering precision = 100 */ return 4; });
            </code>
            </summary>
            <param name="value">New value that will be automatically reverted after action is done</param>
            <param name="action">What should be done under this setting</param>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.op_Implicit(AngouriMath.Convenience.Setting{`0})~`0">
            <summary>
            An implicit operator so that one does not have to call <see cref="P:AngouriMath.Convenience.Setting`1.Value"/>
            </summary>
            <param name="s">The setting</param>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.op_Implicit(`0)~AngouriMath.Convenience.Setting{`0}">
            <summary>
            An implicit operator so that one does not have to call the ctor
            </summary>
            <param name="a">The value</param>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.ToString">
            <summary>
            Overriden ToString so that one could see the value of the setting
            (if overriden)
            </summary>
        </member>
        <member name="P:AngouriMath.Convenience.Setting`1.Value">
            <summary>
            The current value of the setting
            </summary>
        </member>
        <member name="P:AngouriMath.Convenience.Setting`1.Default">
            <summary>
            The default value of the setting
            </summary>
        </member>
        <member name="T:AngouriMath.Convenience.Setting`1.AutoBackRollableTemporarySettingUnit">
            <summary>
            This tiny struct is needed to be under `using` operator, so that your settings
            are automatically rolled back on the end of your method
            <code>
            using var _ = MathS.Settings.SomeSetting.Set(4);
            // do something, once the method is ended, the setting is automatically returned to the initial statement
            </code>
            </summary>
        </member>
        <member name="M:AngouriMath.Convenience.Setting`1.AutoBackRollableTemporarySettingUnit.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity">
            <summary>
            This is the main class in AngouriMath.
            Every node, expression, or number is an <see cref="T:AngouriMath.Entity"/>.
            However, you cannot create an instance of this class, look for the nested classes instead.
            </summary>
        </member>
        <member name="T:AngouriMath.Entity.Variable">
            <summary>
            Variable node. It only has a name.
            Construct a <see cref="T:AngouriMath.Entity.Variable"/> with an implicit conversion from <see cref="T:System.String"/>.
            It has no type, so you can substitute any value under a given variable.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Variable.op_Implicit(System.String)~AngouriMath.Entity.Variable">
            <summary>
            Converts from string to specifically variable
            </summary>
            <param name="expr">Its future name</param>
        </member>
        <member name="P:AngouriMath.Entity.Variable.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.Deconstruct(System.String@)">
            <summary>
            Deconstructs Variable as follows
            </summary>
            <param name="name">To where the result is put</param>
        </member>
        <member name="P:AngouriMath.Entity.Variable.Name">
            <summary>
            The name of the variable as a string
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Variable.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.SplitIndex">
            <summary>
            Extracts this <see cref="T:AngouriMath.Entity.Variable"/>'s name and index
            from its <see cref="P:AngouriMath.Entity.Variable.Name"/> (e. g. "qua" or "phi_3" or "qu_q")
            </summary>
            <returns>
            If this contains _ and valid name and index, returns a pair of
            (<see cref="T:System.String"/> Prefix, <see cref="T:System.String"/> Index),
            <see langword="null"/> otherwise
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Variable.CreateUnique(AngouriMath.Entity,System.String)">
            <summary>
            Finds next var index name that is unused in <paramref name="expr"/> starting with 1, e. g.
            x + n_0 + n_a + n_3 + n_1
            will find n_2
            </summary>
            <remarks>
            This is intended for variables visible to the user.
            For non-visible variables, use <see cref="M:AngouriMath.Entity.Variable.CreateTemp(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Variable})"/> instead.
            </remarks>
        </member>
        <member name="M:AngouriMath.Entity.Variable.CreateTemp(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Variable})">
            <summary>Creates a temporary variable like %1, %2 and %3 that is not in <paramref name="existingVars"/></summary>
            <remarks>
            This is intended for variables not visible to the user.
            For visible variables, use <see cref="M:AngouriMath.Entity.Variable.CreateUnique(AngouriMath.Entity,System.String)"/> instead.
            </remarks>
        </member>
        <member name="M:AngouriMath.Entity.Variable.CreateRandom(AngouriMath.Entity)">
            <summary>
            Used for cases, when the variable should be valid, yet should have no intersection with those existing in the expression
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Variable.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="F:AngouriMath.Entity.Variable.LatexisableConstants">
            <summary>
            List of constants LaTeX will correctly display
            Yet to be extended
            Case does matter, not all letters have both displays in LaTeX
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Variable.Latexise">
            <summary>
            Returns latexised const if it is possible to latexise it,
            or its original name otherwise
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Variable.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Variable.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Matrix">
            <summary>Basic matrix implementation: <a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.op_Implicit(System.String)~AngouriMath.Entity.Matrix">
            <summary>
            Converts from string to specifically tensor
            </summary>
            <param name="expr">From where to parse (available since 1.3)</param>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Codomain">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.InnerMatrix">
            <summary>
            The inner matrix of type <see cref="T:GenericTensor.Core.GenTensor`2"/>.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.#ctor(GenericTensor.Core.GenTensor{AngouriMath.Entity,AngouriMath.Entity.Matrix.EntityTensorWrapperOperations})">
            <summary>
            Creates a <see cref="T:AngouriMath.Entity.Matrix"/> from an instance of <see cref="T:GenericTensor.Core.GenTensor`2"/>.
            Since only 2-dimensional matrices are supported, it will throw an exception if the number
            of dimensions is too high or too low.
            </summary>
            <param name="innerMatrix">
            The instance of a matrix. It will be copied inside. Make sure,
            that it has exactly two dimensions. If a vector needs to be
            created, make it a normal matrix with one column.
            </param>
            <exception cref="T:AngouriMath.Core.Exceptions.InvalidMatrixOperationException">
            Is thrown if the number of dimensions of the passed
            tensor is not 2.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.New(GenericTensor.Core.GenTensor{AngouriMath.Entity,AngouriMath.Entity.Matrix.EntityTensorWrapperOperations})">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.ColumnCount">
            <summary>
            The number of columns of a matrix. It is 1 for vectors.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.RowCount">
            <summary>
            The number of rows for matrices. The number of elements for vectors.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Shape">
            <summary>List of <see cref="T:System.Int32"/>s that stand for dimensions</summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.#ctor(System.Func{System.Int32[],AngouriMath.Entity},System.Int32[])">
            <summary>
            List of dimensions
            If you need matrix, list 2 dimensions 
            If you need vector, list 1 dimension (length of the vector)
            You can't list 0 dimensions
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Item(System.Int32)">
            <summary>
            Returns the i-th element of a vector, or the i-th row of a matrix.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Item(System.Int32,System.Int32)">
            <summary>
            Access the tensor if it is a matrix
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.IsVector">
            <summary>
            Checks whether the matrix only contains one
            column.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.IsRowVector">
            <summary>
            Checks whether it is a row vector, that is,
            the matrix has only one row
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.IsSquare">
            <summary>
            Checks whether the matrix is square (has as many rows as columns)
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.IsScalar">
            <summary>
            Determines whether a matrix is a scalar, that is, a one-by-one matrix
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.AsScalar">
            <summary>
            Casts the matrix to a scalar. It is only
            possible if the matrix is 1x1 size.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.InvalidMatrixOperationException">
            Thrown if the matrix has size different from 1x1.
            </exception>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.T">
            <summary>Changes the order of axes in matrix</summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Determinant">
            <summary>
            Finds the symbolical determinant via Laplace's method
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Inverse">
            <summary>Returns an inverse matrix if it exists</summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.op_Addition(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>
            The Add operator. Performs an active operation
            (elementwise addition of two matrices or vectors)
            and then applies inner simplification
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.op_Subtraction(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>
            The Subtract operator. Performs an active operation
            (elementwise subtraction of two matrices or vectors)
            and then applies inner simplification
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.op_Multiply(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>
            The Multiply operator. Performs an active operation
            (matrix multiplication of two matrices)
            and then applies inner simplification
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.Pow(System.Int32)">
            <summary>
            Performs a binary power of the matrix.
            The matrix must be a square matrix.
            </summary>
            <returns>
            A matrix to the given power with InnerSimplified
            applied.
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.TensorPower(System.Int32)">
            <summary>
            Returns the n-th power of the
            given vector or matrix. It is
            the same as sequential applying 
            n-1 <see cref="M:AngouriMath.Entity.Matrix.TensorProduct(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)"/> to this.
            </summary>
            <param name="exp">
            The power, or the number
            of operands in the a *** a *** ... *** a expression
            </param>
            <returns>
            Non-simplified tensor
            powered vector or matrix. If it
            initially had size n x m, it will have
            the size of 2^n x 2^m.
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.I(System.Int32)">
            <summary>
            Creates a square identity matrix
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.I(System.Int32,System.Int32)">
            <summary>
            Creates a rectangular identity matrix
            with the given size
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.GetEnumerator">
            <summary>
            Gets the enumerator. It is required by the interface
            IEnumerable, which lets us enumerate over the matrix or vector
            </summary>
            <returns></returns>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.RowEchelonForm">
            <summary>
            Matrix's form, transformed via Gaussian elimination.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.ReducedRowEchelonForm">
            <summary>
            Reduced row echelon form via Gaussian elimination.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Rank">
            <summary>
            The number of linearly independent rows
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Adjugate">
            <summary>
            Adjugate form of a matrix
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.MainDiagonal">
            <summary>
            Returns a vector, where the i-th element
            is the [i, i] element of the matrix. The number
            of elements in it equals the minimum of <see cref="P:AngouriMath.Entity.Matrix.RowCount"/> and <see cref="P:AngouriMath.Entity.Matrix.ColumnCount"/>
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Matrix.Trace">
            <summary>
            The trace of a matrix. It is a sum of
            all elements on the main diagonal
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.WithElement(System.Int32,AngouriMath.Entity)">
            <summary>
            Creates a new vector with the specified element being
            set to a new value
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.WithElement(System.Int32,System.Int32,AngouriMath.Entity)">
            <summary>
            Creates a new matrix with the specified element being
            set to a new value
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.WithRow(System.Int32,AngouriMath.Entity.Matrix)">
            <summary>
            Creates a new matrix with the specified row
            set to a new row
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.WithRow(GenericTensor.Core.GenTensor{AngouriMath.Entity,AngouriMath.Entity.Matrix.EntityTensorWrapperOperations},System.Int32,AngouriMath.Entity.Matrix)">
            <summary>
            Creates a new matrix with the specified row
            set to a new row
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.WithColumn(System.Int32,AngouriMath.Entity.Matrix)">
            <summary>
            Creates a new matrix with the specified column
            set to a new column
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.WithColumn(GenericTensor.Core.GenTensor{AngouriMath.Entity,AngouriMath.Entity.Matrix.EntityTensorWrapperOperations},System.Int32,AngouriMath.Entity.Matrix)">
            <summary>
            Creates a new matrix with the specified column
            set to a new column
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.With(System.Func{System.Int32,System.Int32,AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Returns a new matrix/vector of the same shape,
            but with each element replaced by the user.
            </summary>
            <param name="elementByIndex">
            Takes 2 ints which are row number and column
            number of an element, and the current element
            as the third argument.
            </param>
            <example>
            <code>
            var re = O_4.With
                ((rowId, colId, element) => (rowId, colId, element) switch
                {
                    (0, 1, _) => 1,
                    (1, 2, _) => 2,
                    (>1, 3, _) => 6,
                    (var a, var b, _) when a + b &lt; 3 => 8,
                    _ => element
                });
            Console.WriteLine(re.ToString(multilineFormat: true));
            </code>
            The output is going to be:
            <code>
            Matrix[4 x 4]
            8   1   8   0
            8   8   2   0
            8   0   0   6
            0   0   0   6
            </code>
            </example>
            <returns>
            A new matrix or vector with the same shape
            (row count and column count).
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.TensorProduct(AngouriMath.Entity.Matrix,AngouriMath.Entity.Matrix)">
            <summary>
            Finds a tensor product of two matrices
            https://en.wikipedia.org/wiki/Tensor_product
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.ToString(System.Boolean)">
            <summary>
            Gets a string representation of the
            given matrix/vector. If true is
            passed, it will format the inner matrix
            with new lines and paddings to make it
            look like a matrix in plain monospace
            text.
            </summary>
            <param name="multilineFormat">
            Whether to format it into a matrix
            format. If false is passed, it will
            return the same as normal <see cref="M:AngouriMath.Entity.Matrix.ToString"/>.
            </param>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Matrix.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Set_(mathematics)"/>
            A set might be a set operator, conditinal set, finite set, or interval
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.op_Implicit(System.String)~AngouriMath.Entity.Set">
            <summary>
            Converts from string to specifically set
            </summary>
            <param name="expr">From where to parse</param>
        </member>
        <member name="T:AngouriMath.Entity.Set.FiniteSet">
            <summary>
            A finite set is a set whose elements can be counted and enumerated
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.op_Implicit(System.String)~AngouriMath.Entity.Set.FiniteSet">
            <summary>
            Converts from string to specifically finite set
            </summary>
            <param name="expr">From where to parse</param>
        </member>
        <member name="P:AngouriMath.Entity.Set.FiniteSet.Codomain">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.FiniteSet.Elements">
            <summary>
            The IEnumerable of elements of a finite set
            Which is readonly
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Apply(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Applies a function to every element of a set
            and returns a set
            </summary>
            <param name="func">What we do with each element?</param>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.#ctor(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Constructor of a finite set
            Use <see cref="F:AngouriMath.Entity.Set.Empty"/> to create an empty set
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.#ctor(AngouriMath.Entity[])">
            <summary>
            Constructor of a finite set
            Use <see cref="F:AngouriMath.Entity.Set.Empty"/> to create an empty set
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Deconstruct(System.Collections.Generic.IEnumerable{AngouriMath.Entity}@)">
            <summary>
            Deconstructs as record
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.FiniteSet.Count">
            <summary> Represents number of entities in the current set </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.GetEnumerator">
            <summary>
            Used for enumerating. Use "foreach" for iterating over elements
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Equals(AngouriMath.Entity.Set.FiniteSet)">
            <summary>
            Checks that two FiniteSets are equal
            If one is not FiniteSet, the method returns false
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.GetPowerSet">
            <summary>
            Finds such a set that only contains all subsets of the given set
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.TryIsSubsetOf(AngouriMath.Entity.Set.FiniteSet,System.Boolean@)">
            <summary>
            Safely checks whether this is a subset of the argument,
            if successful, returns true AND stores the result in <paramref name="isSub"/>
            </summary>
            <returns>Whether it is possible to determine</returns>
        </member>
        <member name="P:AngouriMath.Entity.Set.FiniteSet.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.FiniteSet.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.FiniteSet.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.Interval">
            <summary>
            An interval represents all numbres in between two Entities
            <see cref="P:AngouriMath.Entity.Set.Interval.LeftClosed"/> stands for whether <see cref="P:AngouriMath.Entity.Set.Interval.Left"/> is included
            <see cref="P:AngouriMath.Entity.Set.Interval.RightClosed"/> stands for whether <see cref="P:AngouriMath.Entity.Set.Interval.Right"/> is included
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.Interval.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.#ctor(AngouriMath.Entity,System.Boolean,AngouriMath.Entity,System.Boolean)">
            <summary>
            An interval represents all numbres in between two Entities
            <see cref="P:AngouriMath.Entity.Set.Interval.LeftClosed"/> stands for whether <see cref="P:AngouriMath.Entity.Set.Interval.Left"/> is included
            <see cref="P:AngouriMath.Entity.Set.Interval.RightClosed"/> stands for whether <see cref="P:AngouriMath.Entity.Set.Interval.Right"/> is included
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.Interval.IsNumeric">
            <summary>
            Checks whether the interval's ends are both numerical (convenient for some evaluations)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.Equals(AngouriMath.Entity.Set.Interval)">
            <summary>
            Checks that two intervals are equal
            If one is not interval, false is returned
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.Interval.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.Interval.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Interval.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.ConditionalSet">
            <summary>
            This is the most abstract set. Technically, you can describe
            any set within this one. Formally, you can define set A of
            a condition F(x) in the following way: for each element x in 
            the Universal x belongs to A if and only if F(x).
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.ConditionalSet.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            This is the most abstract set. Technically, you can describe
            any set within this one. Formally, you can define set A of
            a condition F(x) in the following way: for each element x in 
            the Universal x belongs to A if and only if F(x).
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.ConditionalSet.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.ConditionalSet.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.Equals(AngouriMath.Entity.Set.ConditionalSet)">
            <summary>
            Compares two ConditionalSets
            If one is not CSet, false is returned
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.ConditionalSet.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SpecialSet">
            <summary>
            Special set is something that cannot be easily expressed in other
            types of sets.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.SpecialSet.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Create(AngouriMath.Core.Domain)">
            <summary>
            Creates an instance of special set from a domain
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Create(System.String)">
            <summary>
            Creates an instance of special set from a string
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.SpecialSet.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.SpecialSet.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.MayContain(AngouriMath.Entity)">
            <summary>Checks whether the given element</summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SpecialSet.Booleans">
            <summary>
            A set of all booleans
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Booleans.MayContain(AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Booleans.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Booleans.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SpecialSet.Integers">
            <summary>
            A set of all integers
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Integers.MayContain(AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Integers.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Integers.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SpecialSet.Rationals">
            <summary>
            A set of all rational numbers
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Rationals.MayContain(AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Rationals.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Rationals.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SpecialSet.Reals">
            <summary>
            A set of all real numbers
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Reals.MayContain(AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Reals.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Reals.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SpecialSet.Complexes">
            <summary>
            A set of all complex numbers
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Complexes.MayContain(AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Complexes.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Complexes.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SpecialSet.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.Unionf">
            <summary>
            Unites two sets
            It is true that an entity is in a union if it is at least in one of union's operands
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.Unionf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Unites two sets
            It is true that an entity is in a union if it is at least in one of union's operands
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.Unionf.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.Unionf.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Unionf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.Intersectionf">
            <summary>
            Finds the intersection of two sets
            It is true that an entity is in an intersection if it is in both of intersection's operands
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.Intersectionf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Finds the intersection of two sets
            It is true that an entity is in an intersection if it is in both of intersection's operands
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.Intersectionf.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.Intersectionf.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Intersectionf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.SetMinusf">
            <summary>
            Finds A &amp; !B
            It is true that an entity is in SetMinus if it is in Left but not in Right
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.SetMinusf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Finds A &amp; !B
            It is true that an entity is in SetMinus if it is in Left but not in Right
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.TryContains(AngouriMath.Entity,System.Boolean@)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.SetMinusf.IsSetFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Set.SetMinusf.IsSetEmpty">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.SetMinusf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Set.Inf">
            <summary>
            This node represents whether the given element is in the set
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.Inf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            This node represents whether the given element is in the set
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.Inf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Set.TryContains(AngouriMath.Entity,System.Boolean@)">
            <summary>
            Checks whether the given element is in the set
            </summary>
            <param name="entity">The element to find in the set</param>
            <param name="contains">The result whether it is in the set or not</param>
            <returns>Whether this is possible to determine that it contains the given element</returns>
        </member>
        <member name="M:AngouriMath.Entity.Set.Contains(AngouriMath.Entity)">
            <summary>
            Checks that an element is in the set
            Unless you are confident about the set,
            it is recommended to use <see cref="M:AngouriMath.Entity.Set.TryContains(AngouriMath.Entity,System.Boolean@)"/> instead
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.ElementInSetAmbiguousException">Thrown when </exception>
        </member>
        <member name="F:AngouriMath.Entity.Set.Empty">
            <summary>
            Returns an empty set
            You can use it to compare sets to it
            or to avoid allocations
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.IsSetFinite">
            <summary>
            Checks that a set is finite
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Set.IsSetEmpty">
            <summary>
            Checks that a set does not contain any elements
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Set.Filter(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>
            Adds a constraint to every element of a set.
            1) For a finite set, it will add Provided for every element
            2) For an interval and special set, it will wrap it with a cset (e. g. [a; b].Filter(x > 0, x) -> { x : x in [a; b] and x > 0 })
            3) For a cset, it will add a predicate (e. g. { y : y2 = 3 }.Filter(x > 0, x) -> { y : y2 = 3 and y > 0 })
            </summary>
        </member>
        <member name="T:AngouriMath.Entity.Number">
            <summary>Number node.
            This class represents all possible numerical values as a hierarchy,
            <list>
              <see cref="T:AngouriMath.Entity.Number"/>
              <list type="bullet">
                <see cref="T:AngouriMath.Entity.Number.Complex"/>
                  <list type="bullet">
                    <see cref="T:AngouriMath.Entity.Number.Real"/>
                    <list type="bullet">
                      <see cref="T:AngouriMath.Entity.Number.Rational"/>
                      <list type="bullet">
                        <see cref="T:AngouriMath.Entity.Number.Integer"/>
                      </list>
                    </list>
                  </list>
                </list>
              </list>
            </summary>
        </member>
        <member name="T:AngouriMath.Entity.Number.Complex">
            <summary>
            Extension for <see cref="T:AngouriMath.Entity.Number.Real"/>
            <a href="https://en.wikipedia.org/wiki/Complex_number"/>
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.#ctor(AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real)">
            <summary>
            Constructor does not downcast automatically. Use <see cref="M:AngouriMath.Entity.Number.Complex.Create(AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real)"/> for automatic downcasting
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.RealPart">
            <summary>
            Real part of a complex number
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.ImaginaryPart">
            <summary>
            Imaginary part of a complex number
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.Conjugate">
            <summary>
            Conjugate of a complex number. Given this = a + ib, Conjugate = a - ib
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Complex.ImaginaryOne">
            <summary>
            An imaginary one. You can use it to avoid allocations
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Complex.MinusImaginaryOne">
            <summary>
            An imaginary minus one. You can use it to avoid allocations
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.ThisIsFinite">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.IsExact">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.IsZero">
            <summary>
            Checks if both parts equal 0
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Complex.IsNaN">
            <summary>
            Checks whether the given number is undefined
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Create(AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real)">
            <summary>
            Creates an instance of Complex
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Create(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>
            Creates an instance of Complex
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Deconstruct(AngouriMath.Entity.Number.Real@,AngouriMath.Entity.Number.Real@)">
            <summary>
            Deconstructs as record
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Abs">
            <summary>The magnitude of this <see cref="T:AngouriMath.Entity.Number.Complex"/>.</summary>
            <returns>
            Returns the absolute value of this complex number, to be precise,
            if this = a + ib, this.Abs() -> sqrt(a^2 + b^2)
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Phase">
            <summary>
            The phase of a complex number (aka angle)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.CreatePolar(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)">
            <summary>
            Creates a normal complex from its polar representation
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Complex.NegNegInfinity">
            <summary>-oo + -ooi</summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Complex.NegPosInfinity">
            <summary>-oo + +ooi</summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Complex.PosNegInfinity">
            <summary>+oo + -ooi</summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Complex.PosPosInfinity">
            <summary>+oo + +ooi</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Parse(System.String)">
            <summary>Parses a <see cref="T:System.String"/> into <see cref="T:AngouriMath.Entity.Number.Complex"/></summary>
            <returns><see cref="T:AngouriMath.Entity.Number.Complex"/></returns>
            <exception cref="T:AngouriMath.Core.Exceptions.ParseException">Thrown when <paramref name="source"/> cannot be parsed.</exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.TryParse(System.String,AngouriMath.Entity.Number.Complex@)">
            <summary>Tries to parse a <see cref="T:AngouriMath.Entity.Number.Complex"/> from <see cref="T:System.String"/></summary>
            <param name="source"></param>
            <param name="dst">
            The result will be written to this variable only if parsing was successful,
            if it was not, do not access this variable
            </param>
            <returns>If parsing was successful - <see langword="true"/>, <see langword="false"/> otherwise</returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.ToNumerics">
            <summary>
            Converts the Complex to its of the system module Numerics
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Complex.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Number.Rational">
            <summary>
            The denominator cannot be zero as the resulting value will not be a rational
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Rational.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.#ctor(PeterO.Numbers.ERational)">
            <summary>
            Constructor does not downcast automatically.
            Use <see cref="M:AngouriMath.Entity.Number.Rational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)"/> or <see cref="M:AngouriMath.Entity.Number.Rational.Create(PeterO.Numbers.ERational)"/> for automatic downcasting.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Rational.ERational">
            <summary>
            The PeterO number representation in rational
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Rational.Numerator">
            <summary>
            A getter for the numerator
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Rational.Denominator">
            <summary>
            A getter for the denominator
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Rational.IsExact">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.Create(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>
            Creates an instance of Rational number of two integers
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.Create(PeterO.Numbers.ERational)">
            <summary>
            Creates an instance of Rational number
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.InvalidNumberException">Thrown if </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.Abs">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.FindRational(PeterO.Numbers.EDecimal,System.Int32)">
            <summary>
            Tries to find a pair of two <see cref="T:AngouriMath.Entity.Number.Integer"/>s
            (which are components that make up a <see cref="T:AngouriMath.Entity.Number.Rational"/>)
            so that its rational value is equal to <paramref name="num"/>.
            To set some options for this function, you can use
            <see cref="P:AngouriMath.MathS.Settings.MaxAbsNumeratorOrDenominatorValue"/>
            to limit the absolute value of both denominator and numerator.
            </summary>
            <param name="num">
            e.g. 1.5m -> 3/2
            </param>
            <param name="iterCount">
            Number of iterations allowed to be spent for searching the rational.
            A higher value indicates a higher probability that it will find a <see cref="T:AngouriMath.Entity.Number.Rational"/>.
            Defaults to <see cref="P:AngouriMath.MathS.Settings.FloatToRationalIterCount"/>.
            </param>
            <returns>
            <see cref="T:AngouriMath.Entity.Number.Rational"/> if found, <see langword="null"/> otherwise.
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Rational.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Number.Real">
            <summary>
            Represents a real number, such complex
            that its imaginary part equals 0
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Real.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.#ctor(PeterO.Numbers.EDecimal)">
            <summary>
            Constructor does not downcast automatically. Use <see cref="M:AngouriMath.Entity.Number.Real.Create(PeterO.Numbers.EDecimal)"/> for automatic downcasting.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Real.EDecimal">
            <summary>
            The PeterO number representation in decimal
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.Deconstruct(PeterO.Numbers.EDecimal@)">
            <summary>
            Deconstructs as record
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Real.RealPart">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Number.Real.IsExact">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Number.Real.IsNegative">
            <summary>Strictly less than 0</summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Real.IsPositive">
            <summary>Strictly greater than 0</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.Create(PeterO.Numbers.EDecimal)">
            <summary>
            Creates an instance of Real
            (one can do it by implicit conversation)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.Abs">
            <inheritdoc/>
        </member>
        <member name="F:AngouriMath.Entity.Number.Real.NegativeInfinity">
            <summary>Negative Infinity (-oo)</summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Real.PositiveInfinity">
            <summary>Positive Infinity (+oo)</summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Real.NaN">
            <summary>Not A Number (NaN)</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.AsDouble">
            <summary>
            Converts the given number to a double (not recommended in general unless you need a built-in type)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Real.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Number.Integer">
            <summary>Use <see cref="M:AngouriMath.Entity.Number.Integer.Create(PeterO.Numbers.EInteger)"/> instead of the constructor for consistency with
            <see cref="T:AngouriMath.Entity.Number.Rational"/>, <see cref="T:AngouriMath.Entity.Number.Real"/> and <see cref="T:AngouriMath.Entity.Number.Complex"/>.</summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Integer.Codomain">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Number.Integer.EInteger">
            <summary>
            Represents PeterO number in EInteger
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Integer.Zero">
            <summary>
            A zero, you can use it to avoid allocations
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Integer.One">
            <summary>
            A one, you can use it to avoid allocations
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Number.Integer.MinusOne">
            <summary>
            A minus one, you can use it to avoid allocations
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Create(System.Int32)">
            <summary>
            Creates an instance of Integer
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Create(PeterO.Numbers.EInteger)">
            <summary>
            Creates an instance of Integer
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Phi">
            <summary>
            Computes Euler phi function
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function"/>
            </summary>
            If integer x is non-positive, the result will be 0
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Factorize">
            <summary>
            Factorization of integer
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.CountDivisors">
            <summary>
            Count of all divisors of an integer
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Number.Integer.IsPrime">
            <summary>
            Detemine whether integer is prime or not.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Deconstruct(System.Nullable{System.Int32}@)">
            <summary>
            Deconstructs as record
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Abs">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.IntegerDiv(AngouriMath.Entity.Number.Integer)">
            <summary>
            Performs integer division of the
            number by the given number
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Integer.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Number.IsExact">
            <summary>
            Checks whether the number is not exposed to implicit rounding
            For example, integers and rationals are such
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Decimal">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Double">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Single">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Int32">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Int64">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Numerics.BigInteger">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.op_Explicit(AngouriMath.Entity.Number)~System.Numerics.Complex">
            <summary>
            Casts a <see cref="T:AngouriMath.Entity.Number"/> into a primitive.
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.NumberCastException">
            Thrown when either overflow or the instance of <see cref="T:AngouriMath.Entity.Number"/> cannot be downcasted.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Number.SuperSwitch``1(AngouriMath.Entity.Number,AngouriMath.Entity.Number,System.Func{AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer,``0},System.Func{AngouriMath.Entity.Number.Rational,AngouriMath.Entity.Number.Rational,``0},System.Func{AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real,``0},System.Func{AngouriMath.Entity.Number.Complex,AngouriMath.Entity.Number.Complex,``0})">
            <summary>
            This function serves not only convenience but also protects from unexpected cases, for example,
            if a new type added
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.SuperSwitch``1(``0,``0,System.Func{AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer},System.Func{AngouriMath.Entity.Number.Rational,AngouriMath.Entity.Number.Rational,AngouriMath.Entity.Number.Rational},System.Func{AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real},System.Func{AngouriMath.Entity.Number.Complex,AngouriMath.Entity.Number.Complex,AngouriMath.Entity.Number.Complex})">
            <summary>
            This function serves not only convenience but also protects from unexpected cases, for example,
            if a new type added
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.IsZero(AngouriMath.Entity.Number.Real)">
            <summary>
            Checks whether a number is zero
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.IsZero(PeterO.Numbers.EDecimal)">
            <summary>
            Checks whether a number is zero
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.IsZero(AngouriMath.Entity.Number.Complex)">
            <summary>
            Checks whether a number is zero
            </summary>
            <param name="num"></param>
            <returns></returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.GetAllRootsOf1(PeterO.Numbers.EInteger)">
            <summary>
            Gets all n-th roots of a number,
            that is, all numbers whose n-th power equals 1
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.GetAllRoots(AngouriMath.Entity.Number.Complex,PeterO.Numbers.EInteger)">
            <summary>
            Finds all complex roots of a number
            e. g. sqrt(1) = { -1, 1 }
            root(1, 4) = { -i, i, -1, 1 }
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Sqrt(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of square root of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Exp(AngouriMath.Entity.Number.Complex)">
            <summary>exp(x) = e^x</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Pow(AngouriMath.Entity.Number.Complex,AngouriMath.Entity.Number.Complex)">
            <summary>e.g. Pow(2, 5) = 32</summary>
            <param name="base">The base of the exponential, base^power</param>
            <param name="power">The power of the exponential, base^power</param>
        </member>
        <member name="M:AngouriMath.Entity.Number.Log(AngouriMath.Entity.Number.Complex,AngouriMath.Entity.Number.Complex)">
            <summary>e.g. Log(2, 32) = 5</summary>
            <param name="base">Log's base, log(base, x) is a number y such that base^y = x</param>
            <param name="x">The number of which we want to get its base power</param>
        </member>
        <member name="M:AngouriMath.Entity.Number.Ln(AngouriMath.Entity.Number.Complex)">
            <summary>ln(x) = log(e, x)</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Sin(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of sine of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Secant(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of secant of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Cosecant(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of cosecant of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Arcsecant(AngouriMath.Entity.Number.Complex)">
            <summary>
            sec(x) = value
            1 / cos(x) = value
            1 / value = cos(x)
            x = arccos(1 / value)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Arccosecant(AngouriMath.Entity.Number.Complex)">
            <summary>
            csc(x) = value
            1 / sin(x) = value
            1 / value = sin(x)
            x = arcsin(1 / value)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Signum(AngouriMath.Entity.Number.Complex)">
            <summary>
            Defines the Signum function on complex numbers
            Which is z / |z|
            </summary>
            <param name="num">Number to find Signum of</param>
            <returns>
            A complex signum value for a non-zero argument,
            0 otherwise
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Number.Abs(AngouriMath.Entity.Number.Complex)">
            <summary>
            Complex absolute value
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Cos(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of cosine of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Tan(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of tangent of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Cotan(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of cotangent of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Arcsin(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of arcsine of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Arccos(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of arccosine of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Arctan(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of arctangent of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Arccotan(AngouriMath.Entity.Number.Complex)">
            <summary>Calculates the exact value of arccotangent of num</summary>
        </member>
        <member name="M:AngouriMath.Entity.Number.Factorial(AngouriMath.Entity.Number.Complex)">
            
            <summary>
            Calculates the factorial of the specified <see cref="T:AngouriMath.Entity.Number.Complex"/>.
            
            <para>This implementation uses
            <a href="https://en.wikipedia.org/wiki/Spouge%27s_approximation">Spouge's approximation</a>
            to calculate the factorial for non-integer values.</para>
            
            <para>This involves calculating a series of constants that depend on the desired precision.
            Since this constant calculation is quite expensive (especially for higher precisions),
            the constants for a specific precision will be cached
            and subsequent calls to this method with the same precision will be much faster.</para>
            
            <para>It is therefore recommended to do one call to this method with the standard precision of your application during the startup phase
            and to avoid calling it with many different precisions.</para>
            
            <para>See: <a href="https://en.wikipedia.org/wiki/Factorial#Extension_of_factorial_to_non-integer_values_of_argument">Wikipedia: Factorial - Extension of factorial to non-integer values of argument</a></para>
            </summary>
            <param name="x">The <see cref="T:AngouriMath.Entity.Number.Complex"/></param>
            <returns>The factorial <see cref="T:AngouriMath.Entity.Number.Complex"/></returns>
            <seealso cref="M:AngouriMath.InternalAMExtensions.Factorial(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"/>
            <seealso cref="M:AngouriMath.Entity.Number.Gamma(AngouriMath.Entity.Number.Complex)"/>
            
        </member>
        <member name="M:AngouriMath.Entity.Number.Gamma(AngouriMath.Entity.Number.Complex)">
            <summary>
            Calculates the gamma function of the specified <see cref="T:AngouriMath.Entity.Number.Complex"/>.
            
            <para>This implementation uses {@link #factorial(ComplexNumber, MathContext)} internally,
            therefore the performance implications described there apply also for this method.</para>
            
            <para>See: <a href="https://en.wikipedia.org/wiki/Gamma_function">Wikipedia: Gamma function</a></para>
            </summary>
            <param name="x">The <see cref="T:AngouriMath.Entity.Number.Complex"/></param>
            <returns>The gamma <see cref="T:AngouriMath.Entity.Number.Complex"/></returns>
            <seealso cref="M:AngouriMath.InternalAMExtensions.Gamma(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"/>
            <seealso cref="M:AngouriMath.Entity.Number.Factorial(AngouriMath.Entity.Number.Complex)"/>
        </member>
        <member name="M:AngouriMath.Entity.Number.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Number.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Sumf">
            <summary>
            A node of sum
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Sumf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            A node of sum
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.Sum(System.Collections.Generic.IReadOnlyList{AngouriMath.Entity})">
            <summary>
            Sums all the terms.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.Sum(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Sums all the terms.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.LinearChildren(AngouriMath.Entity)">
            <summary>
            Gathers linear children of a sum, e.g.
            <code>1 + (x - a/2) + b - 4</code>
            would return
            <code>{ 1, x, (-1) * a / 2, b, (-1) * 4 }</code>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sumf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Minusf">
            <summary>
            A node of difference
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Minusf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            A node of difference
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Minusf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Mulf">
            <summary>
            A node of product
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Mulf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            A node of product
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.Multiply(System.Collections.Generic.IReadOnlyList{AngouriMath.Entity})">
            <summary>
            Multiplies all the terms.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.Multiply(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Multiplies all the terms.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.LinearChildren(AngouriMath.Entity)">
            <summary>
            Gathers linear children of a product, e.g.
            <code>1 * (x / a^2) * b / 4</code>
            would return
            <code>{ 1, x, (a^2)^(-1), b, 4^(-1) }</code>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Mulf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Divf">
            <summary>
            A node of division
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Divf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            A node of division
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Divf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Divf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Divf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Sinf">
            <summary>
            A node of sine
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Sinf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of sine
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Sinf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Cosf">
            <summary>
            A node of cosine
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Cosf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of cosine
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Tanf">
            <summary>
            A node of tangent
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Tanf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of tangent
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Tanf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Cotanf">
            <summary>
            A node of cotangent
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Cotanf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of cotangent
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cotanf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Logf">
            <summary>
            A node of logarithm
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Logf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            A node of logarithm
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Logf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Logf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Logf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Powf">
            <summary>
            A node of exponential (power)
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Powf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            A node of exponential (power)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Powf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Powf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Powf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Secantf">
            <summary>
            A node of secant
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Secantf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of secant
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Secantf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Cosecantf">
            <summary>
            A node of secant
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Cosecantf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of secant
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Cosecantf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Arcsecantf">
            <summary>
            A node of arcsecant
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Arcsecantf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of arcsecant
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsecantf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Arccosecantf">
            <summary>
            A node of arccosecant
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Arccosecantf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of arccosecant
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosecantf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Arcsinf">
            <summary>
            A node of arcsine
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Arcsinf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of arcsine
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arcsinf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Arccosf">
            <summary>
            A node of arccosine
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Arccosf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of arccosine
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccosf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Arctanf">
            <summary>
            A node of arctangent
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Arctanf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of arctangent
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arctanf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Arccotanf">
            <summary>
            A node of arccotangent
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Arccotanf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of arccotangent
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Arccotanf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Factorialf">
            <summary>
            A node of factorial
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Factorialf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of factorial
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.New(AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Factorialf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Derivativef">
            <summary>
            A node of derivative
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Derivativef.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.#ctor(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            A node of derivative
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Derivativef.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Integralf">
            <summary>
            A node of integral
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Integralf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.#ctor(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            A node of integral
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.New(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Integralf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Limitf">
            <summary>
            A node of limit
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Limitf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.#ctor(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>
            A node of limit
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.New(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>Reuse the cache by returning the same object if possible</summary>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Limitf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Signumf">
            <summary>
            A node of signum
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Signumf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of signum
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Signumf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Absf">
            <summary>
            A node of abs
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Absf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.#ctor(AngouriMath.Entity)">
            <summary>
            A node of abs
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Absf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Absf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Boolean">
            <summary>
            This node represents all possible values a boolean node might be of
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Boolean.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.#ctor(System.Boolean)">
            <summary>
            This node represents all possible values a boolean node might be of
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Boolean.True">
            <summary>
            One of the Boolean's state, which also behaves as Entity
            That is, hangable
            </summary>
        </member>
        <member name="F:AngouriMath.Entity.Boolean.False">
            <summary>
            One of the Boolean's state, which also behaves as Entity
            That is, hangable
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.op_Implicit(AngouriMath.Entity.Boolean)~System.Boolean">
            <summary>
            This conversation is 100% free, no need to manually choose between
            <see cref="F:AngouriMath.Entity.Boolean.True"/> and <see cref="F:AngouriMath.Entity.Boolean.False"/>
            </summary>
            <param name="b">To convert from</param>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.Create(System.Boolean)">
            <summary>
            Creates a Boolean at 0 cost
            No need to manually choose between <see cref="F:AngouriMath.Entity.Boolean.True"/> and <see cref="F:AngouriMath.Entity.Boolean.False"/>
            </summary>
            <param name="value">
            From which to create
            </param>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.TryParse(System.String,AngouriMath.Entity.Boolean@)">
            <summary>
            Use this when parsing one boolean value
            </summary>
            <param name="expr">A string to parse from</param>
            <param name="dst">Where to store the result</param>
            <returns>
            true if the parsing completed successfully, 
            false otherwise
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.Parse(System.String)">
            <summary>
            Unlike <see cref="M:AngouriMath.Entity.Boolean.TryParse(System.String,AngouriMath.Entity.Boolean@)"/> this will throw a
            <see cref="T:AngouriMath.Core.Exceptions.ParseException"/> if parsing is not successful
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Boolean.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Notf">
            <summary>
            Whatever its argument is, the result will be inverted
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Notf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.#ctor(AngouriMath.Entity)">
            <summary>
            Whatever its argument is, the result will be inverted
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Notf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Notf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Andf">
            <summary>
            Is true iff both operands are true
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Andf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Is true iff both operands are true
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Andf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Andf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Orf">
            <summary>
            Is true iff at least one operand is true,
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Orf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Is true iff at least one operand is true,
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Orf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Orf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Xorf">
            <summary>
            Is true iff one operand is true
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Xorf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Is true iff one operand is true
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Xorf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Impliesf">
            <summary>
            Is true iff assumption is false or conclusion is true
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Impliesf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Is true iff assumption is false or conclusion is true
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Impliesf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Equalsf">
            <summary>
            It is true if left and right are equal
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Equalsf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            It is true if left and right are equal
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Equalsf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Greaterf">
            <summary>
            It is true iff both parts are numeric and real, and left number is greater
            than the right one
            It is false iff both parts are numeric and real, and left number is less or equal 
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Greaterf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            It is true iff both parts are numeric and real, and left number is greater
            than the right one
            It is false iff both parts are numeric and real, and left number is less or equal 
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Greaterf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.GreaterOrEqualf">
            <summary>
            It is true iff both parts are numeric and real, and left number is greater
            than the right one or equal to it
            It is false iff both parts are numeric and real, and left number is less 
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.GreaterOrEqualf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            It is true iff both parts are numeric and real, and left number is greater
            than the right one or equal to it
            It is false iff both parts are numeric and real, and left number is less 
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.GreaterOrEqualf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Lessf">
            <summary>
            It is true iff both parts are numeric and real, and left number is less
            than the right one
            It is false iff both parts are numeric and real, and left number is greater or equal 
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Lessf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            It is true iff both parts are numeric and real, and left number is less
            than the right one
            It is false iff both parts are numeric and real, and left number is greater or equal 
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Lessf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.LessOrEqualf">
            <summary>
            It is true iff both parts are numeric and real, and left number is less
            than the right one or equal to it
            It is false iff both parts are numeric and real, and left number is greater
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.LessOrEqualf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            It is true iff both parts are numeric and real, and left number is less
            than the right one or equal to it
            It is false iff both parts are numeric and real, and left number is greater
            the right one
            It is NaN/unsimplified otherwise.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.LessOrEqualf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Phif">
            <summary>
            This node represents the Euler totient function (phi)
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Phif.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.#ctor(AngouriMath.Entity)">
            <summary>
            This node represents the Euler totient function (phi)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Phif.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Phif.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Providedf">
            <summary>
            That is a node which equals Expression if Predicate is true, otherwise <see cref="F:AngouriMath.MathS.NaN"/>
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Providedf.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.#ctor(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            That is a node which equals Expression if Predicate is true, otherwise <see cref="F:AngouriMath.MathS.NaN"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Providedf.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Entity.Piecewise">
            <summary>
            This is a node which defined on different subsets differently. When evaluating, it will turn
            into a particular case once all cases' predicates before are false, and this case's predicate is true.
            
            That is, the order counts. An example:
            Piecewise(a provided false, b provided true, c provided true)
            Will be evaluated into b,
            
            Piecewise(a provided false, b provided c, c provided false)
            Will remain as it is (although unreachable cases will be removed)
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Piecewise.Codomain">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.#ctor(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf})">
            <summary>
            Creates an instance of Piecewise
            </summary>
            <param name="cases">
            This is an ordered sequence of <see cref="T:AngouriMath.Entity.Providedf"/>
            </param>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.Apply(System.Func{AngouriMath.Entity.Providedf,AngouriMath.Entity.Providedf})">
            <summary>
            Returns a mapped piecewise, with every
            case replaced by the provided case
            </summary>
            <param name="func">
            Map function from a Providedf to a Providedf
            </param>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.Equals(AngouriMath.Entity.Piecewise)">
            <summary>
            Checks that two Piecewise are equal
            If one is not Piecewise, the method returns false
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.ApplyToValues(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Applies the given transformation to every expression of each case
            Predicates, however, remain unchanged
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.InnerEval">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.InnerSimplify">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.Latexise">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.Stringize">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.ToString">
            <inheritdoc/>
        </member>
        <member name="M:AngouriMath.Entity.Piecewise.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.Codomain">
            <summary>
            Coomain of an expression
            If its node value is outside of the domain when evaluated,
            it turns into a <see cref="F:AngouriMath.MathS.NaN"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.WithCodomain(AngouriMath.Core.Domain)">
            <summary>
            Returns this node with the specified codomain, 
            keeping all the subnodes in the same domain they were in
            </summary>
        </member>
        <member name="T:AngouriMath.Entity.ContinuousNode">
            <summary>
            Any node that might be counted as a number, derived, etc. is continuous
            </summary>
        </member>
        <member name="T:AngouriMath.Entity.TrigonometricFunction">
            <summary>
            Describes any function that is related to trigonometry
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.op_Addition(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Hangs two nodes to a Sum node (i. e. building an expression)
            </summary>
            <param name="augend">The left node to add</param>
            <param name="addend">The right node to add</param>
        </member>
        <member name="M:AngouriMath.Entity.op_UnaryPlus(AngouriMath.Entity)">
            <summary>
            Does not do anything until an unary plus node added
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.op_Subtraction(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Hangs two nodes to a Minus node (i. e. building an expression)
            </summary>
            <param name="subtrahend">The left node to add</param>
            <param name="minuend">The right node to add</param>
        </member>
        <member name="M:AngouriMath.Entity.op_UnaryNegation(AngouriMath.Entity)">
            <summary>
            Multiplies the only argument by -1
            </summary>
            <returns>Mul node of -1 and the only argument</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_Multiply(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Hangs two nodes to a Mul node (i. e. building an expression)
            </summary>
            <param name="multiplier">The left node to add</param>
            <param name="multiplicand">The right node to add</param>
        </member>
        <member name="M:AngouriMath.Entity.op_Division(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Hangs two nodes to a Div node (i. e. building an expression)
            </summary>
            <param name="dividend">The left node to add</param>
            <param name="divisor">The right node to add</param>
        </member>
        <member name="M:AngouriMath.Entity.Sin">
            <summary><see cref="M:AngouriMath.MathS.Sin(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Cos">
            <summary><see cref="M:AngouriMath.MathS.Cos(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Tan">
            <summary><see cref="M:AngouriMath.MathS.Tan(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Cotan">
            <summary><see cref="M:AngouriMath.MathS.Cotan(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Sec">
            <summary><see cref="M:AngouriMath.MathS.Sec(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Cosec">
            <summary><see cref="M:AngouriMath.MathS.Cosec(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Arcsec">
            <summary><see cref="M:AngouriMath.MathS.Arcsec(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccosec">
            <summary><see cref="M:AngouriMath.MathS.Arccosec(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Pow(AngouriMath.Entity)">
            <summary><see cref="M:AngouriMath.MathS.Pow(AngouriMath.Entity,AngouriMath.Entity)"/></summary>
            <param name="n">Power</param>
        </member>
        <member name="M:AngouriMath.Entity.Log(AngouriMath.Entity)">
            <summary><see cref="M:AngouriMath.MathS.Log(AngouriMath.Entity,AngouriMath.Entity)"/></summary>
            <param name="x">Antilogarithm (value)</param>
        </member>
        <member name="M:AngouriMath.Entity.Arcsin">
            <summary><see cref="M:AngouriMath.MathS.Arcsin(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccos">
            <summary><see cref="M:AngouriMath.MathS.Arccos(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Arctan">
            <summary><see cref="M:AngouriMath.MathS.Arctan(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Arccotan">
            <summary><see cref="M:AngouriMath.MathS.Arccotan(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Factorial">
            <summary><see cref="M:AngouriMath.MathS.Factorial(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Signum">
            <summary><see cref="M:AngouriMath.MathS.Signum(AngouriMath.Entity)"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Abs">
            <summary><see cref="M:AngouriMath.MathS.Abs(AngouriMath.Entity)"/></summary>
        </member>
        <member name="T:AngouriMath.Entity.Function">
            <summary>
            Describes any node that is a function (e. g. sin, cos, etc.)
            but not an operator or leaf
            </summary>
        </member>
        <member name="T:AngouriMath.Entity.Statement">
            <summary>
            This class describes every node whose value is boolean, that is, true or false.
            </summary>
            <example>
            <code>
            Entity t1 = "a and b"; // Statement
            Entity t2 = "a > b > c"; // Statement
            Entity t3 = "a or b implies x > 0"; // Statement
            
            Entity t4 = "a"; // Not Statement
            Entity t5 = "a + 3"; // Not Statement
            Entity t6 = "a provided c and d"; // Not Statement
            </code>
            </example>
        </member>
        <member name="T:AngouriMath.Entity.ComparisonSign">
            <summary>
            =, &lt;, &gt;, &gt;=, &lt;=
            Nodes <see cref="T:AngouriMath.Entity.Equalsf"/>, <see cref="T:AngouriMath.Entity.Lessf"/>, <see cref="T:AngouriMath.Entity.LessOrEqualf"/>, <see cref="T:AngouriMath.Entity.Greaterf"/>, <see cref="T:AngouriMath.Entity.GreaterOrEqualf"/>
            are assignable to this type.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.op_Implicit(System.Boolean)~AngouriMath.Entity">
            <summary>
            Note, that this operator does not create a new entity. Since
            all entities are immutable, it returns an existing either
            <see cref="F:AngouriMath.Entity.Boolean.True"/> or <see cref="F:AngouriMath.Entity.Boolean.False"/>
            depending on the value of the argument.
            </summary>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_LogicalNot(AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_BitwiseAnd(AngouriMath.Entity,AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_BitwiseOr(AngouriMath.Entity,AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_ExclusiveOr(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            This is an exclusive OR operator. Shouldn't be confused with power!
            </summary>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Xor(AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Implies(AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Equalizes(AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_GreaterThan(AngouriMath.Entity,AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_LessThan(AngouriMath.Entity,AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_GreaterThanOrEqual(AngouriMath.Entity,AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.op_LessThanOrEqual(AngouriMath.Entity,AngouriMath.Entity)">
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.InitDirectChildren">
            <inheritdoc/>
        </member>
        <member name="P:AngouriMath.Entity.DirectChildren">
            <summary>
            Represents all direct children of a node
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Nodes">
            <remarks>A depth-first enumeration is required by
            <see cref="M:AngouriMath.Functions.TreeAnalyzer.GetMinimumSubtree(AngouriMath.Entity,AngouriMath.Entity.Variable)"/></remarks>
            <summary>
            The list of all nodes of the given expression
            </summary>
            <example>
            <code>
            Entity expr = "a + b / 2 ^ 3";
            Console.WriteLine(string.Join(", ", expr.Nodes));
            </code>
            Output:
            <code>
            a + b / 2 ^ 3, a, b / 2 ^ 3, b, 2 ^ 3, 2, 3
            </code>
            </example>
        </member>
        <member name="M:AngouriMath.Entity.Replace(System.Func{AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Applies the given function to every node starting from the leaves
            </summary>
            <param name="func">
            The delegate that takes the current node as an argument and replaces the current node
            with the result of the delegate
            </param>
            <returns>Processed expression</returns>
        </member>
        <member name="M:AngouriMath.Entity.Substitute(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Replaces all <param name="x"/> with <param name="value"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.Substitute(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity},System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Replaces x.x1 with value.v1 and
            x.x2 with value.v2
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Substitute(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity},System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Replaces x.x1 with value.v1 and
            x.x2 with value.v2 and
            x.x3 with value.v3
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Substitute(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity},System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity})">
            <summary>
            Replaces x.x1 with value.v1 and
            x.x2 with value.v2 and
            x.x3 with value.v3 and
            x.x4 with value.v4
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Substitute``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
            <summary>Replaces all <param name="replacements"/></summary>
        </member>
        <member name="P:AngouriMath.Entity.IsFinite">
            <value>
            Whether both parts of the complex number are finite
            meaning that it could be safely used for calculations
            </value>
        </member>
        <member name="P:AngouriMath.Entity.ThisIsFinite">
            <summary>
            Not NaN and not infinity
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.Complexity">
            <value>Number of nodes in tree</value>
        </member>
        <member name="P:AngouriMath.Entity.Vars">
            <summary>
            Set of unique variables, for example 
            it extracts <c>`x`</c>, <c>`goose`</c> from <c>(x + 2 * goose) - pi * x</c>
            </summary>
            <returns>
            Set of unique variables excluding mathematical constants
            such as <see cref="F:AngouriMath.MathS.pi"/> and <see cref="F:AngouriMath.MathS.e"/>
            </returns>
        </member>
        <member name="P:AngouriMath.Entity.VarsAndConsts">
            <summary>
            Set of unique variables, for example 
            it extracts <c>`x`</c>, <c>`goose`</c>, <c>`pi`</c> from <c>(x + 2 * goose) - pi * x</c>
            </summary>
            <returns>
            Set of unique variables and mathematical constants
            such as <see cref="F:AngouriMath.MathS.pi"/> and <see cref="F:AngouriMath.MathS.e"/>
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.ContainsNode(AngouriMath.Entity)">
            <summary>Checks if <paramref name="x"/> is a subnode inside this <see cref="T:AngouriMath.Entity"/> tree.
            Optimized for <see cref="T:AngouriMath.Entity.Variable"/>.</summary>
        </member>
        <member name="M:AngouriMath.Entity.op_Implicit(System.String)~AngouriMath.Entity">
            <summary>
            Implicit conversation from string to Entity
            </summary>
            <param name="expr">The source from which to parse</param>
        </member>
        <member name="P:AngouriMath.Entity.SimplifiedRate">
            <summary>
            Shows how simple the given expression is. The lower - the simpler the expression is.
            You might need it to pick the best expression to represent something. Unlike 
            <see cref="P:AngouriMath.Entity.Complexity"/>, which shows the number of nodes, <see cref="P:AngouriMath.Entity.SimplifiedRate"/> 
            shows how convenient it is to view the expression. This depends on 
            <see cref="P:AngouriMath.MathS.Settings.ComplexityCriteria"/> which can be changed by user.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.IsSymbolic">
            <summary>Checks whether the given expression contains variable</summary>
        </member>
        <member name="P:AngouriMath.Entity.IsConstantLeaf">
            <summary>
            Checks whether the given expression is a finite constant leaf
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.In(AngouriMath.Entity)">
            <summary>
            Creates a node of whether the given element is an element of the given set
            </summary>
            <param name="supSet">
            The assumed super-set of the given expression.
            </param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Provided(AngouriMath.Entity)">
            <summary>
            Creates a node of a expression assuming some condition
            </summary>
            <param name="that">
            A condition under which a given expression (this) is valid.
            </param>
            <returns>A node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Unite(AngouriMath.Entity)">
            <summary>
            Creates a node of union of two nodes (sets)
            </summary>
            <returns>A new node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Intersect(AngouriMath.Entity)">
            <summary>
            Creates a node of intersection of two nodes (sets)
            </summary>
            <returns>A new node</returns>
        </member>
        <member name="M:AngouriMath.Entity.SetSubtract(AngouriMath.Entity)">
            <summary>
            Creates a new node of set difference of two nodes (sets)
            </summary>
            <returns>A new node</returns>
        </member>
        <member name="M:AngouriMath.Entity.SolveBoolean(AngouriMath.Entity.Variable)">
            <summary>
            Solves the given equation over <paramref name="x"/>
            symbolically
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Compile(AngouriMath.Entity.Variable[])">
            <summary>
            Compile function so you can evaluate numerical value 15x faster,
            than subsitution
            </summary>
            <param name="variables">
            List string names of variables in the same order as you will list them when evaluating.
            Constants, i.e. <see cref="F:AngouriMath.MathS.pi"/> and <see cref="F:AngouriMath.MathS.e"/> will be ignored.
            </param>
            <returns></returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile(System.String[])">
            <summary>
            Compile function so you can evaluate numerical value 15x faster,
            than subsitution
            </summary>
            <param name="variables">
            List string names of variables in the same order as you will list them when evaluating.
            Constants, i.e. <see cref="F:AngouriMath.MathS.pi"/> and <see cref="F:AngouriMath.MathS.e"/> will be ignored.
            </param>
            <returns></returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``1(AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol,System.Type,System.Collections.Generic.IEnumerable{System.ValueTuple{System.Type,AngouriMath.Entity.Variable}})">
            <summary>
            Compiles a given expression into a native lambda
            </summary>
            <typeparam name="TDelegate">
            The type of your delegate to convert to
            </typeparam>
            <param name="protocol">
            This is a protocol, according to which all nodes get compiled. Use this
            if you want to use the compilation for types different from those standard
            </param>
            <param name="returnType">
            The type to which the resulting type will be casted
            </param>
            <param name="typesAndNames">
            An <see cref="T:System.Collections.IEnumerable"/> of pairs, where the first element is the type of your argument,
            and the second one is the corresponding variable from the expression
            </param>
            <returns>
            Returnes a natively compiled expression of type <typeparamref name="TDelegate"/>
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``2(AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``3(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``4(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``5(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``6(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``7(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <param name="var6">
            The variable corresponding to the function's argument number 6
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``8(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam>
            <typeparam name="TIn7">
            The type of the passed argument number 7
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <param name="var6">
            The variable corresponding to the function's argument number 6
            </param>
            <param name="var7">
            The variable corresponding to the function's argument number 7
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Compile``9(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a custom compilation protocol.
            </summary>
            <typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam>
            <typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam>
            <typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam>
            <typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam>
            <typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam>
            <typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam>
            <typeparam name="TIn7">
            The type of the passed argument number 7
            </typeparam>
            <typeparam name="TIn8">
            The type of the passed argument number 8
            </typeparam>
            <typeparam name="TOut">
            The return type
            </typeparam>
            <param name="var1">
            The variable corresponding to the function's argument number 1
            </param>
            <param name="var2">
            The variable corresponding to the function's argument number 2
            </param>
            <param name="var3">
            The variable corresponding to the function's argument number 3
            </param>
            <param name="var4">
            The variable corresponding to the function's argument number 4
            </param>
            <param name="var5">
            The variable corresponding to the function's argument number 5
            </param>
            <param name="var6">
            The variable corresponding to the function's argument number 6
            </param>
            <param name="var7">
            The variable corresponding to the function's argument number 7
            </param>
            <param name="var8">
            The variable corresponding to the function's argument number 8
            </param>
            <returns>
            Returns a natively-compiled delegate
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.InnerCompile(AngouriMath.Core.FastExpression.Compiler)">
            <summary>
            Recursive compilation that pushes intructions to the stack (<see cref="P:AngouriMath.Core.FastExpression.Compiler.Instructions"/>)
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Differentiate(AngouriMath.Entity.Variable)">
            <summary>
            Finds the symbolical derivative of the given expression
            </summary>
            <param name="variable">
            Over which variable to find the derivative
            </param>
            <returns>
            The derived expression which might contain <see cref="T:AngouriMath.Entity.Derivativef"/> nodes,
            or the initial one
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Derive(AngouriMath.Entity.Variable)">
            <summary>
            Finds the symbolical derivative of the given expression
            </summary>
            <param name="variable">
            Over which variable to find the derivative
            </param>
            <returns>
            The derived expression which might contain <see cref="T:AngouriMath.Entity.Derivativef"/> nodes,
            or the initial one
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.InnerDifferentiate(AngouriMath.Entity.Variable)">
            <summary>
            Internal differentiation function
            </summary>
            <param name="variable">To derive over</param>
            <returns>The differentiated expressoin or the Derivative node</returns>
        </member>
        <member name="M:AngouriMath.Entity.Differentiate(AngouriMath.Entity.Variable,PeterO.Numbers.EInteger)">
            <summary>Derives over <paramref name="x"/> <paramref name="power"/> times</summary>
        </member>
        <member name="M:AngouriMath.Entity.Integrate(AngouriMath.Entity.Variable)">
            <summary>
            Integrates the given expression over the `x` variable, if can.
            May return an unresolved <see cref="T:AngouriMath.Entity.Integralf"/> node.
            </summary>
            <param name="x">Over which variable to integrate</param>
            <returns>
            An integrated expression. It might remain the same,
            it might have no integrals, and it might be transformed so that
            only a few nodes have unresolved integrals.
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Limit(AngouriMath.Entity.Variable,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>
            Finds the limit of the given expression over the given variable
            </summary>
            <param name="x">
            The variable to be approaching
            </param>
            <param name="destination">
            A value where the variable approaches. It might be a symbolic
            expression, a finite number, or an infinite number, for example,
            "sqrt(x2 + x) / (3x + 3)".Limit("x", "+oo", ApproachFrom.BothSides)
            </param>
            <param name="side">
            From where to approach it: from the left, from the right,
            or BothSides, implying that if limits from either are not
            equal, there is no limit
            </param>
            <returns>
            A result or the <see cref="T:AngouriMath.Entity.Limitf"/> node if the limit
            cannot be determined
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Limit(AngouriMath.Entity.Variable,AngouriMath.Entity)">
            <summary>
            Finds the limit of the given expression over the given variable
            </summary>
            <param name="x">
            The variable to be approaching
            </param>
            <param name="destination">
            A value where the variable approaches. It might be a symbolic
            expression, a finite number, or an infinite number, for example,
            "sqrt(x2 + x) / (3x + 3)".Limit("x", "+oo")
            </param>
            <returns>
            A result or the <see cref="T:AngouriMath.Entity.Limitf"/> node if the limit
            cannot be determined
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.ComputeLimitDivideEtImpera(AngouriMath.Entity.Variable,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Divide_and_rule"/>
            Divide and rule (Latin: divide et impera), or divide and conquer,
            in politics and sociology is gaining and maintaining power by
            breaking up larger concentrations of power into pieces that
            individually have less power than the one implementing the strategy.
            
            In computer science, divide and conquer is an algorithm design paradigm
            based on multi-branched recursion. A divide-and-conquer algorithm works
            by recursively breaking down a problem into two or more sub-problems of
            the same or related type, until these become simple enough to be solved
            directly. The solutions to the sub-problems are then combined to give a
            solution to the original problem.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.SolveEquation(AngouriMath.Entity.Variable)">
            <summary>
            Attempt to find analytical roots of a custom equation.
            It solves the given expression assuming that it is
            equal to zero. No need to make it equal to 0 yourself;
            however, if you prefer so, consider using the .Solve()
            method instead
            </summary>
            <param name="x">
            The variable over which to solve the equation
            </param>
            <example>
            <code>
            Entity expr = "x + 8 - 4";
            Console.WriteLine(expr.SolveEquation("x"));
            </code>
            Will print "{ -4 }"
            </example>
            <returns>
            Returns <see cref="T:AngouriMath.Entity.Set"/>
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Invert(AngouriMath.Entity,AngouriMath.Entity)">
            <summary><para>This <see cref="T:AngouriMath.Entity"/> MUST contain exactly ONE occurance of <paramref name="x"/>,
            otherwise this function won't work correctly.</para>
            
            This function inverts an expression and returns a <see cref="T:AngouriMath.Entity.Set"/>. Here, a represents <paramref name="value"/>.
            <list type="table">
            <item>x^2 = a ⇒ x = { sqrt(a), -sqrt(a) }</item>
            <item>sin(x) = a ⇒ x = { arcsin(a) + 2 pi n, pi - arcsin(a) + 2 pi n }</item>
            </list>
            </summary>
            <returns>A set of possible roots of the expression.</returns>
        </member>
        <member name="M:AngouriMath.Entity.InvertNode(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Use <see cref="M:AngouriMath.Entity.Invert(AngouriMath.Entity,AngouriMath.Entity)"/> instead which auto-simplifies <paramref name="value"/></summary>
        </member>
        <member name="M:AngouriMath.Entity.EntityInBounds(AngouriMath.Entity,AngouriMath.Entity.Number.Complex,AngouriMath.Entity.Number.Complex)">
            <summary>
            Returns true if <paramref name="a"/> is inside a rect with corners <paramref name="from"/>
            and <paramref name="to"/>, OR <paramref name="a"/> is an unevaluable expression
            </summary>        
        </member>
        <member name="M:AngouriMath.Entity.SolveNt(AngouriMath.Entity.Variable)">
            <summary>
            Searches for numerical solutions via Newton's method
            <a href="https://en.wikipedia.org/wiki/Newton%27s_method"/>
            To change parameters see <see cref="P:AngouriMath.MathS.Settings.NewtonSolver"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Solve(AngouriMath.Entity.Variable)">
            <summary>
            Solves a <see cref="T:AngouriMath.Entity.Statement"/>
            Statement is an Entity such that its value is true for
            any x in X, where X is the result of this method.
            See more about <see cref="T:AngouriMath.Entity.Set"/>
            </summary>
            <param name="var">Over which variable to solve</param>
        </member>
        <member name="M:AngouriMath.Entity.ExpandOnTwoArguments(AngouriMath.Entity,AngouriMath.Entity,System.Func{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity},System.Func{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity},System.Boolean)">
            <summary>
            For two-argument nodes
            Used in InnerSimplify and InnerEval
            Allows to avoid looking over all the combinations with piecewise, tensor, finiteset
            </summary>
            <param name="left">
            Left argument
            </param>
            <param name="right">
            Right argument
            </param>
            <param name="operation">
            That is the main switch for the types. It must return null if no suitable couple of types is found,
            so that the method could move on to the matrix choice
            </param>
            <param name="defaultCtor">
            If no suitable case in switch found, it should return the default node, for example, for sum it would be
            <code>(a, b) => a + b</code>
            </param>
            <param name="checkIfExactEvaled">
            Check if the number is exact and, if so, return it.
            </param>
        </member>
        <member name="P:AngouriMath.Entity.EvaluableNumerical">
            <summary>
            Use this to verify whether it is safe to call <see cref="M:AngouriMath.Entity.EvalNumerical"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.EvalNumerical">
            <summary>
            Evaluates a given expression to one number or throws exception
            </summary>
            <returns>
            <see cref="T:AngouriMath.Entity.Number.Complex"/> since new version
            </returns>
            <exception cref="T:AngouriMath.Core.Exceptions.CannotEvalException">
            Thrown when this entity cannot be represented as a simple number.
            <see cref="P:AngouriMath.Entity.EvaluableNumerical"/> should be used to check beforehand.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.InnerSimplify">
            <summary>
            This should NOT be called inside itself
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.InnerSimplified">
            <summary>
            This is the result of naive simplifications. In other 
            symbolic algebra systems it is called "Automatic simplification".
            It only performs an active operation in the first call,
            next time it is free to call it in terms of CPU usage. For
            consistency's sake, consider the call of this property
            as free as the addressing of a field.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.InnerSimplifyWithCheck">
            <summary>
            Make sure you call this function inside of <see cref="M:AngouriMath.Entity.InnerSimplify"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.InnerEval">
            <summary>
            This should NOT be called inside itself
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.InnerEvalWithCheck">
            <summary>
            Make sure you call this function inside of <see cref="M:AngouriMath.Entity.InnerEval"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Expand(System.Int32)">
            <summary>
            Expands an equation trying to eliminate all the parentheses ( e. g. 2 * (x + 3) = 2 * x + 2 * 3 )
            </summary>
            <param name="level">
            The number of iterations (increase this argument in case if some parentheses remain)
            </param>
            <returns>
            An expanded Entity if it wasn't too complicated,
            current entity otherwise
            To change the limit use <see cref="P:AngouriMath.MathS.Settings.MaxExpansionTermCount"/>
            </returns>
        </member>
        <member name="M:AngouriMath.Entity.Factorize(System.Int32)">
            <summary>
            Factorizes an equation trying to eliminate as many power-uses as possible ( e.g. x * 3 + x * y = x * (3 + y) )
            </summary>
            <param name="level">
            The number of iterations (increase this argument if some factor operations are still available)
            </param>
        </member>
        <member name="M:AngouriMath.Entity.Simplify(System.Int32)">
            <summary>
            Simplifies an equation ( e.g. (x - y) * (x + y) -> x^2 - y^2, but 3 * x + y * x = (3 + y) * x )
            </summary>
            <param name="level">
            Increase this argument if you think the equation should be simplified better
            </param>
            <returns></returns>
        </member>
        <member name="M:AngouriMath.Entity.Alternate(System.Int32)">
            <summary>Finds all alternative forms of an expression sorted by their complexity</summary>
        </member>
        <member name="P:AngouriMath.Entity.Evaled">
            <summary>
            Represents the evaluated value of the given expression
            Unlike the result of <see cref="M:AngouriMath.Entity.EvalNumerical"/> and
            <see cref="M:AngouriMath.Entity.EvalBoolean"/>
            this is not constrained by any type.
            
            It only performs an active operation in the first call,
            next time it is free to call it in terms of CPU usage. For
            consistency's sake, consider the call of this property
            as free as the addressing of a field.
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.IsConstant">
            <summary>
            Determines whether a given element can be unambiguously used as a number or boolean
            </summary>
        </member>
        <member name="P:AngouriMath.Entity.EvaluableBoolean">
            <summary>
            Use this to verify whether it is safe to call <see cref="M:AngouriMath.Entity.EvalBoolean"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.EvalBoolean">
            <summary>
            Evaluates a given expression to one boolean or throws exception
            </summary>
            <returns>
            <see cref="T:AngouriMath.Entity.Boolean"/>
            </returns>
            <exception cref="T:AngouriMath.Core.Exceptions.CannotEvalException">
            Thrown when this entity cannot be represented as a simple boolean.
            <see cref="M:AngouriMath.Entity.EvalBoolean"/> should be used to check beforehand.
            </exception>
        </member>
        <member name="M:AngouriMath.Entity.Latexise">
            <summary>
            Returns the expression in LaTeX
            </summary>
            <example>
            <code>
            Entity expr = "a / b + sqrt(c)";
            Console.WriteLine(expr.Latexise());
            </code>
            Output:
            <code>
            \frac{a}{b}+\sqrt{c}
            </code>
            </example>
        </member>
        <member name="M:AngouriMath.Entity.Latexise(System.Boolean)">
            <summary>Returns the expression in LaTeX (for example, a / b -> \frac{a}{b})</summary>
            <param name="parenthesesRequired">Whether to wrap it with parentheses</param>
        </member>
        <member name="M:AngouriMath.Entity.Stringize">
            <summary>
            Converts an expression into a string. Works synonymically into <see cref="M:AngouriMath.Entity.ToString"/>.
            </summary>
        </member>
        <member name="M:AngouriMath.Entity.Stringize(System.Boolean)">
            <summary>
            Converts an expression into a string
            </summary>
            <param name="parenthesesRequired">Whether to wrap with '(' and ')'</param>
        </member>
        <member name="M:AngouriMath.Entity.ToSymPy">
            <summary>Generates Python code that you can use with sympy</summary>
        </member>
        <member name="M:AngouriMath.Entity.ToSymPy(System.Boolean)">
            <summary>
            Generates python code without any additional symbols that can be run in SymPy
            </summary>
            <param name="parenthesesRequired">
            Whether to wrap it with parentheses
            Usually depends on its parental nodes
            </param>
        </member>
        <member name="M:AngouriMath.Entity.Choice(AngouriMath.Functions.TreeAnalyzer.SortLevel,System.String,System.String,System.String)">
            <summary>
            Returns the correct way for sort string
            </summary>
            <param name="level">The level at which we are sorting</param>
            <param name="highLevel">The most general way (that is, the least uniqueness of the string)</param>
            <param name="middleLevel">The one in between (for example, for grouping some functions)</param>
            <param name="lowLevel">The most unique string id</param>
        </member>
        <member name="M:AngouriMath.Entity.Choice(AngouriMath.Functions.TreeAnalyzer.SortLevel,System.String,System.String)">
            <summary>
            Returns the correct way for sort string
            </summary>
            <param name="level">The level at which we are sorting</param>
            <param name="highLevel">The most general way (that is, the least uniqueness of the string)</param>
            <param name="lowLevel">The most unique string id</param>
        </member>
        <member name="M:AngouriMath.Entity.SortHash(AngouriMath.Functions.TreeAnalyzer.SortLevel)">
            <summary>Hash that is convenient to sort with</summary>
        </member>
        <member name="T:AngouriMath.Core.Antlr.AngouriMathBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:AngouriMath.Core.Antlr.IAngouriMathListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterFactorial_expression(AngouriMath.Core.Antlr.AngouriMathParser.Factorial_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.factorial_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitFactorial_expression(AngouriMath.Core.Antlr.AngouriMathParser.Factorial_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.factorial_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterPower_list(AngouriMath.Core.Antlr.AngouriMathParser.Power_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitPower_list(AngouriMath.Core.Antlr.AngouriMathParser.Power_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterPower_expression(AngouriMath.Core.Antlr.AngouriMathParser.Power_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitPower_expression(AngouriMath.Core.Antlr.AngouriMathParser.Power_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterUnary_expression(AngouriMath.Core.Antlr.AngouriMathParser.Unary_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.unary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitUnary_expression(AngouriMath.Core.Antlr.AngouriMathParser.Unary_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.unary_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterMult_expression(AngouriMath.Core.Antlr.AngouriMathParser.Mult_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.mult_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitMult_expression(AngouriMath.Core.Antlr.AngouriMathParser.Mult_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.mult_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterSum_expression(AngouriMath.Core.Antlr.AngouriMathParser.Sum_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.sum_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitSum_expression(AngouriMath.Core.Antlr.AngouriMathParser.Sum_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.sum_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterSet_operator_intersection(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_intersectionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_intersection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitSet_operator_intersection(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_intersectionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_intersection"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterSet_operator_union(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_unionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_union"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitSet_operator_union(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_unionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_union"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterSet_operator_setsubtraction(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_setsubtractionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_setsubtraction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitSet_operator_setsubtraction(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_setsubtractionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_setsubtraction"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterIn_operator(AngouriMath.Core.Antlr.AngouriMathParser.In_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.in_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitIn_operator(AngouriMath.Core.Antlr.AngouriMathParser.In_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.in_operator"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterInequality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Inequality_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.inequality_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitInequality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Inequality_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.inequality_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterTerms_list(AngouriMath.Core.Antlr.AngouriMathParser.Terms_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.terms_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitTerms_list(AngouriMath.Core.Antlr.AngouriMathParser.Terms_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.terms_list"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterEquality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Equality_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.equality_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitEquality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Equality_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.equality_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterNegate_expression(AngouriMath.Core.Antlr.AngouriMathParser.Negate_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.negate_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitNegate_expression(AngouriMath.Core.Antlr.AngouriMathParser.Negate_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.negate_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterAnd_expression(AngouriMath.Core.Antlr.AngouriMathParser.And_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.and_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitAnd_expression(AngouriMath.Core.Antlr.AngouriMathParser.And_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.and_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterXor_expression(AngouriMath.Core.Antlr.AngouriMathParser.Xor_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.xor_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitXor_expression(AngouriMath.Core.Antlr.AngouriMathParser.Xor_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.xor_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterOr_expression(AngouriMath.Core.Antlr.AngouriMathParser.Or_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.or_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitOr_expression(AngouriMath.Core.Antlr.AngouriMathParser.Or_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.or_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterImplies_expression(AngouriMath.Core.Antlr.AngouriMathParser.Implies_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.implies_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitImplies_expression(AngouriMath.Core.Antlr.AngouriMathParser.Implies_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.implies_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterProvided_expression(AngouriMath.Core.Antlr.AngouriMathParser.Provided_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.provided_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitProvided_expression(AngouriMath.Core.Antlr.AngouriMathParser.Provided_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.provided_expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterExpression(AngouriMath.Core.Antlr.AngouriMathParser.ExpressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitExpression(AngouriMath.Core.Antlr.AngouriMathParser.ExpressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterFunction_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Function_argumentsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.function_arguments"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitFunction_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Function_argumentsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.function_arguments"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterInterval_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Interval_argumentsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.interval_arguments"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitInterval_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Interval_argumentsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.interval_arguments"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterCset_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Cset_argumentsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.cset_arguments"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitCset_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Cset_argumentsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.cset_arguments"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterAtom(AngouriMath.Core.Antlr.AngouriMathParser.AtomContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.atom"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitAtom(AngouriMath.Core.Antlr.AngouriMathParser.AtomContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.atom"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterStatement(AngouriMath.Core.Antlr.AngouriMathParser.StatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.statement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitStatement(AngouriMath.Core.Antlr.AngouriMathParser.StatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.statement"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:AngouriMath.Core.Antlr.AngouriMathBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:AngouriMath.Core.Antlr.IAngouriMathListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:AngouriMath.Core.Antlr.AngouriMathParser"/>.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterFactorial_expression(AngouriMath.Core.Antlr.AngouriMathParser.Factorial_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.factorial_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitFactorial_expression(AngouriMath.Core.Antlr.AngouriMathParser.Factorial_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.factorial_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterPower_list(AngouriMath.Core.Antlr.AngouriMathParser.Power_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitPower_list(AngouriMath.Core.Antlr.AngouriMathParser.Power_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterPower_expression(AngouriMath.Core.Antlr.AngouriMathParser.Power_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitPower_expression(AngouriMath.Core.Antlr.AngouriMathParser.Power_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.power_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterUnary_expression(AngouriMath.Core.Antlr.AngouriMathParser.Unary_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.unary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitUnary_expression(AngouriMath.Core.Antlr.AngouriMathParser.Unary_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.unary_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterMult_expression(AngouriMath.Core.Antlr.AngouriMathParser.Mult_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.mult_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitMult_expression(AngouriMath.Core.Antlr.AngouriMathParser.Mult_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.mult_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterSum_expression(AngouriMath.Core.Antlr.AngouriMathParser.Sum_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.sum_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitSum_expression(AngouriMath.Core.Antlr.AngouriMathParser.Sum_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.sum_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterSet_operator_intersection(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_intersectionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_intersection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitSet_operator_intersection(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_intersectionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_intersection"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterSet_operator_union(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_unionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_union"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitSet_operator_union(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_unionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_union"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterSet_operator_setsubtraction(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_setsubtractionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_setsubtraction"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitSet_operator_setsubtraction(AngouriMath.Core.Antlr.AngouriMathParser.Set_operator_setsubtractionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.set_operator_setsubtraction"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterIn_operator(AngouriMath.Core.Antlr.AngouriMathParser.In_operatorContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.in_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitIn_operator(AngouriMath.Core.Antlr.AngouriMathParser.In_operatorContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.in_operator"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterInequality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Inequality_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.inequality_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitInequality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Inequality_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.inequality_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterTerms_list(AngouriMath.Core.Antlr.AngouriMathParser.Terms_listContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.terms_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitTerms_list(AngouriMath.Core.Antlr.AngouriMathParser.Terms_listContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.terms_list"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterEquality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Equality_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.equality_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitEquality_expression(AngouriMath.Core.Antlr.AngouriMathParser.Equality_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.equality_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterNegate_expression(AngouriMath.Core.Antlr.AngouriMathParser.Negate_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.negate_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitNegate_expression(AngouriMath.Core.Antlr.AngouriMathParser.Negate_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.negate_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterAnd_expression(AngouriMath.Core.Antlr.AngouriMathParser.And_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.and_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitAnd_expression(AngouriMath.Core.Antlr.AngouriMathParser.And_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.and_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterXor_expression(AngouriMath.Core.Antlr.AngouriMathParser.Xor_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.xor_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitXor_expression(AngouriMath.Core.Antlr.AngouriMathParser.Xor_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.xor_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterOr_expression(AngouriMath.Core.Antlr.AngouriMathParser.Or_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.or_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitOr_expression(AngouriMath.Core.Antlr.AngouriMathParser.Or_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.or_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterImplies_expression(AngouriMath.Core.Antlr.AngouriMathParser.Implies_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.implies_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitImplies_expression(AngouriMath.Core.Antlr.AngouriMathParser.Implies_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.implies_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterProvided_expression(AngouriMath.Core.Antlr.AngouriMathParser.Provided_expressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.provided_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitProvided_expression(AngouriMath.Core.Antlr.AngouriMathParser.Provided_expressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.provided_expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterExpression(AngouriMath.Core.Antlr.AngouriMathParser.ExpressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitExpression(AngouriMath.Core.Antlr.AngouriMathParser.ExpressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterFunction_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Function_argumentsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.function_arguments"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitFunction_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Function_argumentsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.function_arguments"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterInterval_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Interval_argumentsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.interval_arguments"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitInterval_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Interval_argumentsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.interval_arguments"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterCset_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Cset_argumentsContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.cset_arguments"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitCset_arguments(AngouriMath.Core.Antlr.AngouriMathParser.Cset_argumentsContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.cset_arguments"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterAtom(AngouriMath.Core.Antlr.AngouriMathParser.AtomContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.atom"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitAtom(AngouriMath.Core.Antlr.AngouriMathParser.AtomContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.atom"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.EnterStatement(AngouriMath.Core.Antlr.AngouriMathParser.StatementContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.statement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:AngouriMath.Core.Antlr.IAngouriMathListener.ExitStatement(AngouriMath.Core.Antlr.AngouriMathParser.StatementContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:AngouriMath.Core.Antlr.AngouriMathParser.statement"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:AngouriMath.Core.ConstantFieldAttribute">
            <summary>
            Use this attribute on those static fields that do not require thread static attribute
            because they are constant
            </summary>
        </member>
        <member name="T:AngouriMath.Core.ConcurrentFieldAttribute">
            <summary>
            Use this attribute on those static fields that are already synchronized
            internally or explicitly
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Domain">
            <summary>
            Specify the domain used within a record 
            </summary>
        </member>
        <member name="F:AngouriMath.Core.Domain.Boolean">
            <summary>
            The domain of all boolean values (true, false)
            </summary>
        </member>
        <member name="F:AngouriMath.Core.Domain.Integer">
            <summary>
            The domain of all integer values
            </summary>
        </member>
        <member name="F:AngouriMath.Core.Domain.Rational">
            <summary>
            The domain of all rational values
            </summary>
        </member>
        <member name="F:AngouriMath.Core.Domain.Real">
            <summary>
            The domain of all real values
            </summary>
        </member>
        <member name="F:AngouriMath.Core.Domain.Complex">
            <summary>
            The domain of all complex values
            </summary>
        </member>
        <member name="F:AngouriMath.Core.Domain.Any">
            <summary>
            The domain of all values (might be removed in the future)
            </summary>
        </member>
        <member name="T:AngouriMath.Core.ILatexiseable">
            <summary>
            Any class that supports converting to LaTeX format should implement this interface
            </summary>
        </member>
        <member name="M:AngouriMath.Core.ILatexiseable.Latexise">
            <summary>
            Converts the object to the LaTeX format
            That is, a string that can be later displayed and rendered as LaTeX
            </summary>
        </member>
        <member name="T:AngouriMath.Core.IUnaryNode">
            <summary>
            From this interface all single-argument nodes are inherited
            </summary>
        </member>
        <member name="P:AngouriMath.Core.IUnaryNode.NodeChild">
            <summary>
            The only child of the node
            </summary>
        </member>
        <member name="T:AngouriMath.Core.IBinaryNode">
            <summary>
            From this interface all double-argument nodes are inherited
            </summary>
        </member>
        <member name="P:AngouriMath.Core.IBinaryNode.NodeFirstChild">
            <summary>
            The left child of the node
            </summary>
        </member>
        <member name="P:AngouriMath.Core.IBinaryNode.NodeSecondChild">
            <summary>
            The right child of the node
            </summary>
        </member>
        <member name="T:AngouriMath.Core.EquationSystem">
            <summary>
            A class for systems of equations. Is not part of AM's ecosystem,
            that is, it is not an Entity, just an intermediate class.
            It is a system of arbitrary equations, not only those linear. However,
            it is not a system of <see cref="T:AngouriMath.Entity.Statement"/>s.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.EquationSystem.#ctor(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            The equations you pass should not have an <see cref="M:AngouriMath.MathS.Equality(AngouriMath.Entity,AngouriMath.Entity)"/> node.
            After having created a system of equations, you may solve or latexise it.
            </summary>
            <param name="equations">
            Any <see cref="T:System.Collections.Generic.IEnumerable`1"/> parameter, such as <see cref="T:System.Collections.Generic.List`1"/> or <see cref="T:System.Array"/>.
            </param>
            <example>
            <code>
            var eq = new EquationSystem(new Entity[] {
                "x + sin(y)2 + 3",
                "y - a"
            });
            </code>
            </example>
        </member>
        <member name="M:AngouriMath.Core.EquationSystem.#ctor(AngouriMath.Entity[])">
            <summary>
            The equations you pass should not have an <see cref="M:AngouriMath.MathS.Equality(AngouriMath.Entity,AngouriMath.Entity)"/> node.
            After having created a system of equations, you may solve or latexise it.
            </summary>
            <param name="equations">
            An <see cref="T:System.Array"/>
            </param>
            <example>
            <code>
            var eq = new EquationSystem(
                "x + sin(y)2 + 3",
                "y - a"
            );
            </code>
            </example>
        </member>
        <member name="M:AngouriMath.Core.EquationSystem.Solve(AngouriMath.Entity.Variable[])">
            <summary>
            Solves a system of equations, if possible.
            </summary>
            <param name="vars">
            The umber of variables must match number of equations
            </param>
            <return>
            If there exists at least one solution, returns a solution matrix
            The first axis of the matrix corresponds to the number of solutions,
            the second one corresponds to the number of variables.
            
            The i-th column of the matrix represents the possible values of the i-th variable.
            
            If no solution was found, returns a null.
            </return>
        </member>
        <member name="M:AngouriMath.Core.EquationSystem.Latexise">
            <returns>
            Latexised version of the system. It adds
            zero equality to all the provided expressions
            </returns>
        </member>
        <member name="M:AngouriMath.Core.EquationSystem.ToString">
            <inheritdoc/>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.AngouriMathBaseException">
            <summary>
            This is the base exception of all exceptions thrown by AngouriMath. 
            If one needs to catch all exceptions from AngouriMath, it is enough
            to catch this one
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.ParseException">
            <summary>Thrown when trying to parse an invalid string</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.UnhandledParseException">
            <summary>Can only occur in the ANTLR parser when it is unclear what exactly happened</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.InvalidArgumentParseException">
            <summary>Thrown when an invalid argument passed to a AM's function</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.MissingOperatorParseException">
            <summary>
            Is thrown only when the explicit parsing mode is enabled and the input misses
            some operator, for example, 2x should be 2 * x with explicit parsing mode.
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.UnrecognizedDomainException">
            <summary>Thrown when non-known domain is passed to the domain function</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.CannotParseInstanceException">
            <summary>
            May be thrown when trying to parse an instance from a string
            </summary>
            <example>
            <code>
            Set set = "{ 1, 2 }"; // not thrown
            Set set = "1 + 2"; // thrown
            </code>
            </example>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.FunctionArgumentCountException">
            <summary>
            Thrown when a wrong number of arguments are encountered when parsing a function
            from a string.
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.AngouriBugException">
            <summary>If one was thrown, the exception is probably not foreseen by AM. Report it is an issue</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.FutureReleaseException">
            <summary>
            Is thrown when the requested feature is still under developing
            or not considered to be developed at all
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.NotSufficientlySupportedException">
            <summary>
            In case if AM or other parts do not support something, 
            for example, it may occur if either AM or SymPy does not
            support some specific feature
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.MathSException">
            <summary>If one is thrown, the user's input is invalid</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.LimitOperationNotSupportedException">
            <summary>Thrown inside operations related to limits</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.InvalidNumberException">
            <summary>Thrown when an invalid number is passed as an argument</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.WrongNumberOfArgumentsException">
            <summary>Quite general, is thrown when too many or too few of whatever is provided</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.TreeException">
            <summary>Thrown when an invalid node or combination of nodes in the expression tree is encountered</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.UncompilableNodeException">
            <summary>Thrown when trying to compile and a node cannot be compiled</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.CannotEvalException">
            <summary>Is thrown when something cannot be collapsed into a single number or boolean</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.ElementInSetAmbiguousException">
            <summary> Cannot figure out whether the entity is in the set </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.SolveRequiresStatementException">
            <summary> Thrown if instead of a statement another expression is put into Solve </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.InvalidMatrixOperationException">
            <summary>
            Thrown in matrix operations
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.InvalidNumericSystemException">
            <summary>
            Occurs when an invalid numeric system was provided to functions 
            <see cref="M:AngouriMath.MathS.ToBaseN(AngouriMath.Entity.Number.Real,System.Int32)"/> or <see cref="M:AngouriMath.MathS.FromBaseN(System.String,System.Int32)"/>
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.NumberCastException">
            <summary>Thrown when invalid cast encountered</summary>
        </member>
        <member name="T:AngouriMath.Core.Exceptions.InvalidProtocolProvided">
            <summary>
            Occurs when no custom compilation protocol was provided, while the built-in one
            does not have the given type defined for the given operator. To resolve it,
            create your own <see cref="T:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol"/>.
            </summary>
        </member>
        <member name="T:AngouriMath.Core.FiniteSetBuilder">
            <summary>
            Use this class for solvers and other places when a set needs to be built
            and you want to avoid using lists. It builds an instance of <see cref="T:AngouriMath.Entity.Set.FiniteSet"/>.
            </summary>
        </member>
        <member name="P:AngouriMath.Core.FiniteSetBuilder.IsEmpty">
            <summary>
            Checks whether the number of elements added to the builder is zero
            </summary>
        </member>
        <member name="M:AngouriMath.Core.FiniteSetBuilder.#ctor">
            <summary>
            Creates an instance of <see cref="T:AngouriMath.Core.FiniteSetBuilder"/> with no elements.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.FiniteSetBuilder.#ctor(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Creates an instance of <see cref="T:AngouriMath.Core.FiniteSetBuilder"/> with elements, provided in the argument.
            It does not check for uniqueness of elements, however, it will be performed automatically once
            you will call the <see cref="M:AngouriMath.Core.FiniteSetBuilder.ToFiniteSet"/> method.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.FiniteSetBuilder.Add(AngouriMath.Entity)">
            <summary>
            It does not check for uniqueness of elements, however, it will be performed automatically once
            you will call the <see cref="M:AngouriMath.Core.FiniteSetBuilder.ToFiniteSet"/> method.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.FiniteSetBuilder.Remove(AngouriMath.Entity)">
            <summary>
            Removes a given element from the builder
            </summary>
            <param name="element">
            The element to remove. If no such element was found, method
            silently exits.
            </param>
        </member>
        <member name="M:AngouriMath.Core.FiniteSetBuilder.ToFiniteSet">
            <summary>
            Build itself into a <see cref="T:AngouriMath.Entity.Set.FiniteSet"/> entity. This method
            can be called multiple times throughout its lifetime.
            </summary>
            <example>
            <code>
            var builder = new FiniteSetBuilder();
            Console.WriteLine(builder.ToFiniteSet());
            builder.Add(3);
            Console.WriteLine(builder.ToFiniteSet());
            builder.Add(4);
            Console.WriteLine(builder.ToFiniteSet());
            builder.Add(5);
            Console.WriteLine(builder.ToFiniteSet());
            </code>
            </example>
            <returns>
            An immutable <see cref="T:AngouriMath.Entity.Set.FiniteSet"/> entity.
            </returns>
        </member>
        <member name="T:AngouriMath.Core.MatrixBuilder">
            <summary>
            Use this class for solvers and other places when a matrix needs to be built without
            recreating an instance multiple times. It builds an instance of <see cref="T:AngouriMath.Entity.Matrix"/>.
            It enables to build a tensor row-by-row.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.MatrixBuilder.#ctor(System.Int32)">
            <summary>
            Creates a builder with the given number of column and no rows.
            </summary>
            <param name="columnCount">
            The number of columns the tensor will have (you cannot change it after creation).
            </param>
        </member>
        <member name="M:AngouriMath.Core.MatrixBuilder.#ctor(System.Collections.Generic.List{System.Collections.Generic.List{AngouriMath.Entity}},System.Int32)">
            <summary>
            Creates a builder with the given number of column and no rows.
            </summary>
            <param name="alreadyHas">
            The list of rows to put in the builder. All lists in this list
            must have the same length as columnCount.
            </param>
            <param name="columnCount">
            The number of columns the tensor will have (you cannot change it after creation).
            </param>
        </member>
        <member name="M:AngouriMath.Core.MatrixBuilder.Add(System.Collections.Generic.List{AngouriMath.Entity})">
            <summary>
            Adds a row to the builder.
            </summary>
            <param name="row">
            A row to add. Make sure it has the same length as columnCount.
            </param>
            <exception cref="T:AngouriMath.Core.Exceptions.InvalidMatrixOperationException">
            Is thrown if the given row has a wrong length.
            </exception>
        </member>
        <member name="M:AngouriMath.Core.MatrixBuilder.Add(System.Collections.Generic.IEnumerable{AngouriMath.Entity})">
            <summary>
            Adds a row to the builder.
            </summary>
            <param name="row">
            A row to add. Make sure it has the same length as columnCount.
            </param>
            <exception cref="T:AngouriMath.Core.Exceptions.InvalidMatrixOperationException">
            Is thrown if the given row has a wrong length.
            </exception>
        </member>
        <member name="M:AngouriMath.Core.MatrixBuilder.ToMatrix">
            <summary>
            Builds itself into a <see cref="T:AngouriMath.Entity.Matrix"/>.
            </summary>
            <returns>
            An immutable <see cref="T:AngouriMath.Entity.Matrix"/> if there exists at least one row.
            Null otherwise.
            </returns>
        </member>
        <member name="T:AngouriMath.Core.ReasonOfFailureWhileParsing">
            <summary>
            Nesting class for reasons of why parsing could fail. The type union for it
            is 
            </summary>
        </member>
        <member name="T:AngouriMath.Core.ReasonOfFailureWhileParsing.Unknown">
            <summary>
            The error is an unclassified error returned by the
            ANTLR's parser.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.ReasonOfFailureWhileParsing.Unknown.#ctor(System.String)">
            <summary>
            The error is an unclassified error returned by the
            ANTLR's parser.
            </summary>
        </member>
        <member name="T:AngouriMath.Core.ReasonOfFailureWhileParsing.MissingOperator">
            <summary>
            This error is when the explicit parsing mode is enabled,
            but the input lacks an operator (which is normally inserted
            automatically with explicit parsing mode turned off). For
            example, "2x" would give this error.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.ReasonOfFailureWhileParsing.MissingOperator.#ctor(System.String)">
            <summary>
            This error is when the explicit parsing mode is enabled,
            but the input lacks an operator (which is normally inserted
            automatically with explicit parsing mode turned off). For
            example, "2x" would give this error.
            </summary>
        </member>
        <member name="T:AngouriMath.Core.ReasonOfFailureWhileParsing.InternalError">
            <summary>
            This is a bug of AngouriMath. Something that we definitely
            do not expect. More: <see cref="T:AngouriMath.Core.Exceptions.AngouriBugException"/>.
            Please, report to the main repository.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.ReasonOfFailureWhileParsing.InternalError.#ctor(System.String)">
            <summary>
            This is a bug of AngouriMath. Something that we definitely
            do not expect. More: <see cref="T:AngouriMath.Core.Exceptions.AngouriBugException"/>.
            Please, report to the main repository.
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Parser.InsertOmittedTokensOrProvideDiagnostic(System.Collections.Generic.IList{Antlr4.Runtime.IToken},AngouriMath.Core.Antlr.AngouriMathLexer)">
            <summary>
            This method inserts omitted tokens when no
            explicit-only parsing is enabled. Otherwise,
            it will throw an exception.
            </summary>
        </member>
        <member name="T:AngouriMath.Core.FastExpression">
            <summary>
            Compiled function (not to a delegate, but to AM's VM readable format)
            </summary>
        </member>
        <member name="T:AngouriMath.Core.FastExpression.Compiler">
            <summary>The <ref name="Cache"/> stores the saved cache number if zero/positive,
            or the bitwise complement of the unsaved cache number if negative.</summary>
        </member>
        <member name="M:AngouriMath.Core.FastExpression.Compiler.#ctor(System.Collections.Generic.List{AngouriMath.Core.FastExpression.Instruction},System.Collections.Generic.IReadOnlyDictionary{AngouriMath.Entity.Variable,System.Int32},System.Collections.Generic.IDictionary{AngouriMath.Entity,System.Int32})">
            <summary>The <ref name="Cache"/> stores the saved cache number if zero/positive,
            or the bitwise complement of the unsaved cache number if negative.</summary>
        </member>
        <member name="M:AngouriMath.Core.FastExpression.Compiler.Compile(AngouriMath.Entity,System.Collections.Generic.IEnumerable{AngouriMath.Entity.Variable})">
            <summary>Returns a compiled expression. Allows to boost substitution a lot</summary>
            <param name="func">The function to be compiled</param>
            <param name="variables">Must be equal to func's variables (ignoring constants)</param>
        </member>
        <member name="M:AngouriMath.Core.FastExpression.#ctor(System.Int32,System.Collections.Generic.List{AngouriMath.Core.FastExpression.Instruction},System.Int32)">
            <summary>
            You cannot modify this function once it is sealed. The final user will never access to its
            direct instructions
            </summary>
        </member>
        <member name="M:AngouriMath.Core.FastExpression.Call(System.Numerics.Complex[])">
            <summary>Calls the compiled function (synonym to <see cref="M:AngouriMath.Core.FastExpression.Substitute(System.Numerics.Complex[])"/>)</summary>
            <param name="values">List arguments in the same order in which you compiled the function</param>
        </member>
        <member name="M:AngouriMath.Core.FastExpression.Substitute(System.Numerics.Complex[])">
            <summary>Calls the compiled function (synonym to <see cref="M:AngouriMath.Core.FastExpression.Call(System.Numerics.Complex[])"/>)</summary>
            <param name="values">List arguments in the same order in which you compiled the function</param>
            <exception cref="T:AngouriMath.Core.Exceptions.WrongNumberOfArgumentsException">
            Thrown when the length of <paramref name="values"/> does not match the number of variables compiled.
            </exception>
        </member>
        <member name="M:AngouriMath.Core.FastExpression.ToString">
            <summary>Might be useful for debug if a function works too slowly</summary>
        </member>
        <member name="T:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol">
            <summary>
            This class describes all the type conversions for 
            </summary>
        </member>
        <member name="P:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol.ConstantConverter">
            <summary>
            Change this method if you want a custom converter from number and boolean into the necessary type
            </summary>
        </member>
        <member name="P:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol.BinaryNodeConverter">
            <summary>
            Change this if you want to override compilation node for binary nodes
            </summary>
        </member>
        <member name="P:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol.UnaryNodeConverter">
            <summary>
            Change this if you want to override compilation node for unary nodes
            </summary>
        </member>
        <member name="P:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocol.AnyArgumentConverter">
            <summary>
            Change this if you want to override compilation node for non-unary and non-binary nodes
            </summary>
        </member>
        <member name="T:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocolBuiltinConstantConverters">
            <summary>
            It is a storage of default constant converters that you can use
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocolBuiltinConstantConverters.ConverterConstant(AngouriMath.Entity)">
            <summary>
            This treats any number as <see cref="T:AngouriMath.Entity.Number.Complex"/> and any boolean as <see cref="T:System.Boolean"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocolBuiltinConstantConverters.TwoArgumentEntity(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,AngouriMath.Entity)">
            <summary>
            This is a default converter for binary nodes (for those inherited from <see cref="T:AngouriMath.Core.IBinaryNode"/>)
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocolBuiltinConstantConverters.OneArgumentEntity(System.Linq.Expressions.Expression,AngouriMath.Entity)">
            <summary>
            This is a default converter for unary nodes (for those inherited from <see cref="T:AngouriMath.Core.IUnaryNode"/>)
            </summary>
        </member>
        <member name="M:AngouriMath.Core.Compilation.IntoLinq.CompilationProtocolBuiltinConstantConverters.AnyArgumentEntity(System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression},AngouriMath.Entity)">
            <summary>
            This is a default converter for other (non-unary and non-binary) nodes
            </summary>
        </member>
        <member name="T:AngouriMath.Core.ApproachFrom">
            <summary>
            Where to tend to the given number in limits
            </summary>
        </member>
        <member name="F:AngouriMath.Core.ApproachFrom.BothSides">
            <summary>
            Means that the limit is considered valid if and only if
            Left-sided limit exists and Right-sided limit exists
            and they are equal
            </summary>
        </member>
        <member name="F:AngouriMath.Core.ApproachFrom.Left">
            <summary>
            If x tends from the left, i. e. it is never greater than the destination
            </summary>
        </member>
        <member name="F:AngouriMath.Core.ApproachFrom.Right">
            <summary>
            If x tends from the right, i. e. it is never less than the destination
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.BaseConversion.IntToBaseN(PeterO.Numbers.EInteger,System.Int32)">
            <summary>Transforms an integer to the corresponding base (in string)</summary>
        </member>
        <member name="M:AngouriMath.Functions.BaseConversion.FloatToBaseN(PeterO.Numbers.EDecimal,System.Int32)">
            <summary>Transforms a floating number, but this number should be in [0; 1]</summary>
        </member>
        <member name="M:AngouriMath.Functions.BaseConversion.ToBaseN(PeterO.Numbers.EDecimal,System.Int32)">
            <summary>
            if a number is A + B where A is integer and B is in [0; 1], it performs operations
            for A and B separately and then concatenates
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.BaseConversion.IntFromBaseN(System.String,System.Int32)">
            <summary>Gets an integer from a string which should not contain any of ,.-</summary>
        </member>
        <member name="M:AngouriMath.Functions.BaseConversion.FloatFromBaseN(System.String,System.Int32)">
            <summary>if num is ABC, the initial number was 0.ABC</summary>
        </member>
        <member name="M:AngouriMath.Functions.BaseConversion.FromBaseN(System.String,System.Int32)">
            <summary>
            Performs operations on both the integer and floating parts of a number and concatenates
            </summary>
        </member>
        <member name="T:AngouriMath.Functions.Boolean.BooleanSolver">
            <summary>
            This is set of very simple algorithms
            It's an analogue of Newton Solver as it doesn't represent its answer
            symbolically
            Use 
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Boolean.BooleanSolver.SolveTable(AngouriMath.Entity,AngouriMath.Entity.Variable[])">
            <summary>
            Returns a tensor of solutions over <paramref name="variables"/> so that
            the expression turns into a True when evaled. Computes the roots by
            compiling the truth table
            </summary>
            <exception cref="T:AngouriMath.Core.Exceptions.WrongNumberOfArgumentsException"/>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.Integration.Integrate(AngouriMath.Entity,AngouriMath.Entity.Variable,System.ValueTuple{PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal},System.ValueTuple{PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal},System.Int32)">
            <summary>
            Numerical definite integration
            See more at <see cref="M:AngouriMath.MathS.Compute.DefiniteIntegral(AngouriMath.Entity,AngouriMath.Entity.Variable,PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal)"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.EquationSolver.Solve(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>Solves one equation</summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.EquationSolver.SolveSystem(System.Collections.Generic.IEnumerable{AngouriMath.Entity},System.ReadOnlySpan{AngouriMath.Entity.Variable})">
            <summary>
            Solves a system of equations by solving one after another with substitution, e.g. <br/>
            let { x - y + a = 0, y + 2a = 0 } be a system of equations for variables { x, y } <br/>
            Then we first find y from the first equation, <br/>
            y = x + a <br/>
            then we substitute it to all others <br/>
            x + a + 2a = 0 <br/>
            then we find x <br/>
            x = -3a <br/>
            Then we substitute back <br/>
            y = -3a + a = -2a <br/>
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.EquationSolver.InSolveSystem(System.Collections.Generic.List{AngouriMath.Entity},System.ReadOnlySpan{AngouriMath.Entity.Variable})">
            <summary>Solves system of equations</summary>
            <param name="equations"><see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:AngouriMath.Entity"/></param>
            <param name="vars">
            <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:AngouriMath.Entity.Variable"/>s,
            where each of them must be mentioned in at least one entity from equations
            </param>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.AnalyticalEquationSolver.Solve(AngouriMath.Entity,AngouriMath.Entity.Variable,System.Boolean)">
            <summary>Equation solver</summary>
            <param name="compensateSolving">
            Compensate solving is needed when you formatted an equation to (something - const)
            and compensateSolving "compensates" this by applying expression inverter,
            aka compensating the equation formed by the previous solver
            </param>
            <param name="expr">Expression</param>
            <param name="x">Variable to solve over</param>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.CommonDenominatorSolver.FindFractions(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>
            All constants, no matter multiplied or divided, are numerator's coefficients:
            2 * x / 3 => num: 2 / 3
            
            All entities that contain x and have a real negative power are denominator's multipliers
            2 / (x + 3) => den: [x + 3]
            2 / ((x^(-1) + 3) * (x2 + 1)) => den: [x^(-1) + 3, x2 + 1]
            
            All entities that have complex power are considered as product of an entity with a real power
            and an entity whole power's real part is 0
            x ^ (-1 + 2i) => num: x ^ (2i), den: [x]
            x ^ (3 - 2i) => num: x ^ (3 - 2i), den: []
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.CommonDenominatorSolver.TrySolveGCD(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity.Set@)">
            <summary>
            Finds the best common denominator, multiplies the whole expression by that, and
            tries solving if the found denominator is not 1
            </summary>
        </member>
        <member name="T:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver">
            <summary>Solves all forms of Polynomials that are trivially solved</summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.SolveLinear(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Solves ax + b</summary>
            <param name="a">Coefficient of x</param>
            <param name="b">Free coefficient</param>
            <returns>Set of roots</returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.SolveQuadratic(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Solves ax^2 + bx + c</summary>
            <param name="a">Coefficient of x^2</param>
            <param name="b">Coefficient of x</param>
            <param name="c">Free coefficient</param>
            <returns>Set of roots</returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.SolveCubic(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Solves ax^3 + bx^2 + cx + d</summary>
            <param name="a">Coefficient of x^3</param>
            <param name="b">Coefficient of x^2</param>
            <param name="c">Coefficient of x</param>
            <param name="d">Free coefficient</param>
            <returns>Set of roots</returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.SolveQuartic(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity)">
            <summary>Solves ax^4 + bx^3 + cx^2 + dx + e</summary>
            <param name="a">Coefficient of x^4</param>
            <param name="b">Coefficient of x^3</param>
            <param name="c">Coefficient of x^2</param>
            <param name="d">Coefficient of x</param>
            <param name="e">Free coefficient</param>
            <returns>Set of roots</returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.ReduceCommonPower(System.Collections.Generic.Dictionary{PeterO.Numbers.EInteger,AngouriMath.Entity}@)">
            <summary>
            So that the final list of powers contains power = 0 and all powers >= 0
            (e. g. if the dictionaty's keys are 3, 4, 6, the final answer will contain keys
            0, 1, 3, if the dictionary's keys are -2, 0, 3, the final answer will contain keys
            0, 2, 5)
            </summary>
            <param name="monomials">
            Dictionary to process. Key - power, value - coefficient of the corresponding term
            </param>
            <returns>
            Whether all initial powers where > 0 (if so, x = 0 is a root)
            </returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.SolveAsPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>Tries to solve as polynomial</summary>
            <param name="expr">Polynomial of an expression</param>
            <param name="subtree">
            The expression the polynomial of (e. g. cos(x)^2 + cos(x) + 1 is a polynomial of cos(x))
            </param>
            <returns>A finite <see cref="T:AngouriMath.Entity.Set"/> if successful, <see langword="null"/> otherwise</returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.GatherMonomialInformation``2(System.Collections.Generic.IEnumerable{AngouriMath.Entity},AngouriMath.Entity.Variable)">
            <summary>Finds all terms of a polynomial</summary>
            <returns><see langword="null"/> if polynomial is bad</returns>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.PolynomialSolver.GatherMonomialInformationAllowingBad``2(System.Collections.Generic.IEnumerable{AngouriMath.Entity},AngouriMath.Entity.Variable)">
            <summary>Finds all terms of a polynomial</summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.AnalyticalSolving.AnalyticalInequalitySolver.Solve(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>
            Considers expr > 0
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Algebra.NumericalSolving.NewtonSolver.SolveNt(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.MathS.Settings.NewtonSetting)">
            <summary>Performs a grid search with each iteration done by NewtonIter</summary>
            <param name="expr">The equation with one variable to be solved</param>
            <param name="v">The variable to solve over</param>
            <param name="settings">
            Some settings regarding how we should perform the Newton solver process
            A complex number, thus, if stepCount.Im == 0, no operations will be performed at all. If you
            need to iterate over real numbers only, set it to 1, i. e. new Number(your_number, 1)
            How many approximations we need to do before we reach the most precise result.
            </param>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.GetMinimumSubtree(AngouriMath.Entity,AngouriMath.Entity.Variable)">
            <summary>
            Searches for a subtree containing `ent` and being minimal possible size.
            For example, for expr = MathS.Sqr(x) + 2 * (MathS.Sqr(x) + 3) the result
            will be MathS.Sqr(x) while for MathS.Sqr(x) + x the minimum subtree is x.
            Further, it will be used for solving with variable replacing, for example,
            there's no pattern for solving equation like sin(x)^2 + sin(x) + 1 = 0,
            but we can first solve t^2 + t + 1 = 0, and then root = sin(x).
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.IsZero(AngouriMath.Entity)">
            <summary>
            If an evaluable expression is equal to zero, <see langword="true"/>, otherwise, <see langword="false"/>
            For example, 1 - 1 is zero, but 1 + a is not
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.EstimateTermCount(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>
            Finds out how many terms we get after expansion via binomial coefficients, e. g
            (a + b) ^ 3 -> 2, 3 -> 4
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.GatherLinearChildrenOverSumAndExpand(AngouriMath.Entity,System.Func{AngouriMath.Entity,System.Boolean})">
            <summary>
            Returns a list of linear children over sum
            where at most one term doesn't contain x, e. g.
            x2 + x + a + b + x
            =>
            [x2, x, a + b, x]
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.CombinateSums(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>
            CombinateSums(3, 5) ->
            { 0, 0, 5 }, { 0, 1, 4 }, { 0, 2, 3 }, { 0, 3, 2 }, { 0, 4, 1 },
            { 0, 5, 0 }, { 1, 0, 4 }, { 1, 1, 3 }, { 1, 2, 2 }, { 1, 3, 1 },
            { 1, 4, 0 }, { 2, 0, 3 }, { 2, 1, 2 }, { 2, 2, 1 }, { 2, 3, 0 },
            { 3, 0, 2 }, { 3, 1, 1 }, { 3, 2, 0 }, { 4, 0, 1 }, { 4, 1, 0 }, { 5, 0, 0 }
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.SmartExpandOver(AngouriMath.Entity,System.Func{AngouriMath.Entity,System.Boolean})">
            <summary><paramref name="expr"/> is NEITHER <see cref="T:AngouriMath.Entity.Sumf"/> NOR <see cref="T:AngouriMath.Entity.Minusf"/></summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.PolynomialLongDivision(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Divides one polynomial over another one:
            <a href="https://en.wikipedia.org/wiki/Polynomial_long_division"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.TryGetPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable,System.Collections.Generic.Dictionary{PeterO.Numbers.EInteger,AngouriMath.Entity}@)">
            <summary>
            Finds all monomials with respect to the power of <paramref name="variable"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.TryGetPolyLinear(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@,AngouriMath.Entity@)">
            <summary>a x + b</summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.TryGetPolyQuadratic(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@,AngouriMath.Entity@,AngouriMath.Entity@)">
            <summary>a x ^ 2 + b x + c</summary>
        </member>
        <member name="M:AngouriMath.Functions.TreeAnalyzer.MultiHangBinary(System.Collections.Generic.IReadOnlyList{AngouriMath.Entity},System.Func{AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity})">
            <summary>Binary multi hanging: ((1 + 1) + (1 + 1))</summary>
        </member>
        <member name="M:AngouriMath.Functions.ExpressionNumerical.AreEqual(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity[])">
            <summary>
            Checks if two expressions are equivalent if 
            <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/> does not give the
            expected response
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.ExpressionNumerical.AreEqual(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Checks if two expressions are equivalent if 
            <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/> does not give the
            expected response
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Fraction.Decompose(AngouriMath.Entity.Number.Integer,AngouriMath.Entity.Number.Integer)">
            <summary>
            Decomposes an arbitrary rational
            number into sum of rationals a_i / p_i^k,
            where p_i is a prime number. Evaluates
            lazily.
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.SortRules(AngouriMath.Functions.TreeAnalyzer.SortLevel)">
            <summary>Actual sorting with <see cref="M:AngouriMath.Entity.SortHash(AngouriMath.Functions.TreeAnalyzer.SortLevel)"/></summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.ExpandFactorialDivisions(AngouriMath.Entity)">
            <summary>(x + a)! / (x + b)! -> (x+b+1)*(x+b+2)*...*(x+a)</summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.FactorizeFactorialMultiplications(AngouriMath.Entity)">
            <summary>(x-1)! x -> x!, x! (x+1) -> (x+1)!, etc. <!--as well as z! (-z-1)! -> -π/sin(π z)--></summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.InvertNegativePowers(AngouriMath.Entity)">
            <summary>a ^ (-1) => 1 / a</summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.InvertNegativeMultipliers(AngouriMath.Entity)">
            <summary>1 + (-x) => 1 - x</summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.NormalTrigonometricForm(AngouriMath.Entity)">
            <summary>
            For this it is true that any trigonometric function is either sin or cos
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Patterns.TrigonometricToExponentialRules(AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)">
            <summary>
            Here, we replace x with t which represents e^(ix).
            <list type="table">
            <item>sin(ax + b) = (t^a * e^(i*b) - t^(-a) * e^(-i*b)) / (2i)</item>
            <item>cos(ax + b) = (t^a * e^(i*b) + t^(-a) * e^(-i*b)) / 2</item>
            </list>
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Simplificator.Simplify(AngouriMath.Entity,System.Int32)">
            <summary>See more details in <see cref="M:AngouriMath.Entity.Simplify(System.Int32)"/></summary>
        </member>
        <member name="M:AngouriMath.Functions.Simplificator.Alternate(AngouriMath.Entity,System.Int32)">
            <summary>Finds all alternative forms of an expression</summary>
        </member>
        <member name="M:AngouriMath.Functions.Simplificator.TryPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@)">
            <summary>
            Sorts an expression into a polynomial.
            See more at <see cref="M:AngouriMath.MathS.TryPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@)"/>
            </summary>
        </member>
        <member name="M:AngouriMath.Functions.Simplificator.DivideByEntityStrict(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            Divides the given expression by the divisor.
            Requires a given node to exactly match the divisor,
            so no "smart" division can be applied.
            (e. g. pi / 2 divide by pi would work, but
            (2 a) / 2 won't be divided by 4a)
            </summary>
            <returns>The result if valid, null otherwise</returns>
        </member>
        <member name="M:AngouriMath.Functions.Simplificator.RepresentRational(AngouriMath.Entity.Number.Rational,System.Collections.Generic.IEnumerable{AngouriMath.Entity.Number.Rational})">
            <summary>
            If it can, it will find coefficients 
            [a_1, a_2, ..., a_n] such that for
            given rational forms [p_1, p_2, ..., p_n]
            it is true that 
            q = a_1 * p_1 + a_2 * p_2 + ... + a_n * p_n
            </summary>
            <returns>
            The sequence of pairs coef-form or
            null if it cannot find them
            </returns>
        </member>
        <member name="M:AngouriMath.Functions.TrigonometricAngleExpansion.GetSineOfHalvedAngle(AngouriMath.Entity,AngouriMath.Entity)">
            <summary>
            We are given angle thetaRat and sin(theta)
            where thetaRat = theta / pi.
            This function returns sin(theta / 2).
            </summary>
            <param name="thetaRat">
            An angle already divided by pi
            </param>
            <param name="sin2x">
            The value of the sine
            of the doubled angle
            </param>
            <returns>
            The value of sine of half of the
            given angle if can (null otherwise)
            </returns>
        </member>
        <member name="M:AngouriMath.Functions.TrigonometricAngleExpansion.ExpandSineArgumentMultiplied(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            Assume you have sin(n x), where
            n is an integer number. Then
            sin(n x) can be easily represented
            as a combination of arithmetic operations
            of sin(x) and cos(x), which is exactly what
            this function does.
            </summary>
            <param name="sinx">
            The value of sin(x)
            </param>
            <param name="cosx">
            The value of cos(x)
            </param>
            <param name="n">
            The integer multiplier of the
            angle in the original sin(n x)
            </param>
            <returns>
            Expanded sine.
            </returns>
        </member>
        <member name="M:AngouriMath.Functions.TrigonometricAngleExpansion.ExpandCosineArgumentMultiplied(AngouriMath.Entity,AngouriMath.Entity,System.Int32)">
            <summary>
            Assume you have cos(n x), where
            n is an integer number. Then
            cos(n x) can be easily represented
            as a combination of arithmetic operations
            of sin(x) and cos(x), which is exactly what
            this function does.
            </summary>
            <param name="sinx">
            The value of sin(x)
            </param>
            <param name="cosx">
            The value of cos(x)
            </param>
            <param name="n">
            The integer multiplier of the
            angle in the original cos(n x)
            </param>
            <returns>
            Expanded cosine.
            </returns>
        </member>
        <member name="F:AngouriMath.Functions.TrigonometryTableValues.TableSin">
            <summary>
            Credit: https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals#List_of_trigonometric_constants_of_2%CF%80/n
            Although some formulas have been changed because they are wrong on Wikipedia
            </summary>
        </member>
        <member name="T:AngouriMath.InternalAMExtensions">
            <summary>
            This is a set of extensions for internal use. You might be more interested
            in publicly exposed <see cref="T:AngouriMath.Extensions.AngouriMathExtensions"/> or function class <see cref="T:AngouriMath.MathS"/>
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.ConcatTuples``1(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``0}})">
            <summary>
            Concatenates 2-element tuples into an IEnumerable
            { (1, 2), (3, 4), (5, 6) } -> { 1, 2, 3, 4, 5, 6 }
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.SequencesAreEqualReferences``1(System.ValueTuple{System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Checks that if the sequences point to the same object or that all elements of them point to the same objects
            </summary>
        </member>
        <member name="P:AngouriMath.InternalAMExtensions.ConstantCache.Pi">
            <summary>Represents <see cref="F:System.Math.PI"/></summary>
        </member>
        <member name="P:AngouriMath.InternalAMExtensions.ConstantCache.TwoPi">
            <summary>Represents 2 * <see cref="F:System.Math.PI"/></summary>
        </member>
        <member name="P:AngouriMath.InternalAMExtensions.ConstantCache.HalfPi">
            <summary>Represents <see cref="F:System.Math.PI"/> / 2</summary>
        </member>
        <member name="P:AngouriMath.InternalAMExtensions.ConstantCache.QuarterPi">
            <summary>Represents <see cref="F:System.Math.PI"/> / 4</summary>
        </member>
        <member name="P:AngouriMath.InternalAMExtensions.ConstantCache.E">
            <summary>Represents <see cref="F:System.Math.E"/></summary>
        </member>
        <member name="P:AngouriMath.InternalAMExtensions.ConstantCache.Half">
            <summary>Represents 0.5</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Lcm(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary>
            <a href="https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor"/>
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Combinations(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)">
            <summary><a href="https://en.wikipedia.org/wiki/Combination"/>, equivalent to nCr
            or <a href="https://en.wikipedia.org/wiki/Binomial_coefficient"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Phi(PeterO.Numbers.EInteger)">
            <summary>
            Computes Euler phi function
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function"/>
            </summary>
            If integer x is non-positive, the result will be 0
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Phi(System.Int64)">
            <summary>
            Computes Euler phi function (for long)
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function"/>
            </summary>
            If integer x is non-positive, the result will be 0
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Factorize(PeterO.Numbers.EInteger)">
            <summary>
            Factorization of integer
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.CountDivisors(PeterO.Numbers.EInteger)">
            <summary>
            Count of all divisors of an integer
            </summary>
            If integer x is non-positive, the result will be 0
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Cos(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Cos(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Tan(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Tan(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.CalculateSinFromCos(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,AngouriMath.InternalAMExtensions.ConstantCache,PeterO.Numbers.EContext)">
            <summary>Helper function for calculating sin(x) from cos(x)</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Sin(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Sin(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Secant(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>
            1 / Cos(x)
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Cosecant(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>
            1 / Sin(x)
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Arcsecant(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>
            sec(x) = value
            1 / cos(x) = value
            1 / value = cos(x)
            x = arccos(1 / value)
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Arccosecant(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>
            csc(x) = value
            1 / sin(x) = value
            1 / value = sin(x)
            x = arcsin(1 / value)
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.TruncateToPeriodicInterval(PeterO.Numbers.EDecimal@,AngouriMath.InternalAMExtensions.ConstantCache,PeterO.Numbers.EContext)">
            <summary>Truncates <paramref name="x"/> to [-2*<see cref="F:System.Math.PI"/>, 2*<see cref="F:System.Math.PI"/>] </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Arcsin(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Asin(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Arctan(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Atan(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Acos(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Acos(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Arctan2(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>
            Analogy of <see cref="M:System.Math.Atan2(System.Double,System.Double)"/> for more see this
            <img src="http://i.imgur.com/TRLjs8R.png"/>
            </summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Sinh(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Sinh(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Cosh(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Cosh(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Tanh(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            <summary>Analogy of <see cref="M:System.Math.Tanh(System.Double)"/></summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Round(PeterO.Numbers.EDecimal)">
            <summary>Rounds half up to nearest integer</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Truncate(PeterO.Numbers.EDecimal)">
            <summary>Rounds towards zero to nearest integer</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.SplitDecimal(PeterO.Numbers.EDecimal)">
            <summary>Splits decimal into integral part and fractional part.
            The fractional part is guaranteed to be positive.</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Ceiling(PeterO.Numbers.EDecimal)">
            <summary>If there is a fractional part, returns the next smallest integer</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Floor(PeterO.Numbers.EDecimal)">
            <summary>If there is a fractional part, returns the previous largest integer</summary>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Factorial(System.Int32)">
                        <summary>
                        Calculates the factorial of the specified integer argument.
                        <para>factorial = 1 * 2 * 3 * ... n</para>
                        </summary>
                        <param name="n">The <see cref="T:System.Int32"/>.</param>
                        <returns>The factorial <see cref="T:PeterO.Numbers.EInteger"/>.</returns>
                        <exception cref="T:System.ArgumentOutOfRangeException">Thrown if x &lt; 0</exception>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Factorial(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
             <summary>
             Calculates the factorial of the specified <see cref="T:PeterO.Numbers.EDecimal"/>.
            
             <para>This implementation uses
             <a href="https://en.wikipedia.org/wiki/Spouge%27s_approximation">Spouge's approximation</a>
             to calculate the factorial for non-integer values.</para>
            
             <para>This involves calculating a series of constants that depend on the desired precision.
             Since this constant calculation is quite expensive (especially for higher precisions),
             the constants for a specific precision will be cached
             and subsequent calls to this method with the same precision will be much faster.</para>
            
             <para>It is therefore recommended to do one call to this method with the standard precision of your application during the startup phase
             and to avoid calling it with many different precisions.</para>
            
             <para>See: <a href="https://en.wikipedia.org/wiki/Factorial#Extension_of_factorial_to_non-integer_values_of_argument">Wikipedia: Factorial - Extension of factorial to non-integer values of argument</a></para>
             </summary>
            
             <param name="x">The <see cref="T:PeterO.Numbers.EDecimal"/></param>
             <param name="mathContext">The <see cref="T:PeterO.Numbers.EContext"/> used for the result</param>
             <returns>The factorial <see cref="T:PeterO.Numbers.EDecimal"/></returns>
             <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the precision of the <paramref name="mathContext"/> is outside the int32 range</exception>
             <seealso cref="M:AngouriMath.InternalAMExtensions.Factorial(System.Int32)"/>
             <seealso cref="M:AngouriMath.InternalAMExtensions.Gamma(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"/>
        </member>
        <member name="M:AngouriMath.InternalAMExtensions.Gamma(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)">
            	     * <summary>
            	     * Calculates the gamma function of the specified <see cref="T:PeterO.Numbers.EDecimal"/>.
            	     *
            	     * This implementation uses <see cref="M:AngouriMath.InternalAMExtensions.Factorial(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)"/> internally,
            	     * therefore the performance implications described there apply also for this method.
            	     *
            	     * </summary>
            	     * <para>See: <a href="https://en.wikipedia.org/wiki/Gamma_function">Wikipedia: Gamma function</a></para>
            	     * <param name="x">The <see cref="T:PeterO.Numbers.EDecimal"/></param>
            	     * <param name="mathContext">The <see cref="T:PeterO.Numbers.EContext"/> used for the result</param>
            	     * <returns>The gamma <see cref="T:PeterO.Numbers.EDecimal"/></returns>
                     * <exception cref="T:System.ArgumentOutOfRangeException">Thrown when the precision of the <paramref name="mathContext"/> is outside the <see cref="T:System.Int32"/> range</exception>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
                Reserved to be used by the compiler for tracking metadata.
                This class should not be used by developers in source code.
            </summary>
            <remarks>
                This definition is provided by the <i>IsExternalInit</i> NuGet package (https://www.nuget.org/packages/IsExternalInit).
                Please see https://github.com/manuelroemer/IsExternalInit for more information.
            </remarks>
        </member>
    </members>
</doc>
